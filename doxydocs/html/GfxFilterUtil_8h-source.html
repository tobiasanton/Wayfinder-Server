<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: GfxFilterUtil.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Shared</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>GfxFilterUtil.h</h1><a href="GfxFilterUtil_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (c) 1999 - 2010, Vodafone Group Services Ltd</span>
00003 <span class="comment">All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
00008 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
00009 <span class="comment">    * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
00010 <span class="comment"></span>
00011 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#ifndef GFX_FILTER_UTIL_H</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define GFX_FILTER_UTIL_H</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#include "<a class="code" href="config_8h.html">config.h</a>"</span>
00018 <span class="preprocessor">#include "math.h"</span>
00019 <span class="preprocessor">#include "stdlib.h"</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="GfxUtility_8h.html">GfxUtility.h</a>"</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="MC2Coordinate_8h.html">MC2Coordinate.h</a>"</span>
00024 <span class="preprocessor">#include &lt;vector&gt;</span>
00025 <span class="preprocessor">#include &lt;list&gt;</span>
00026 
<a name="l00057"></a><a class="code" href="classGfxFilterUtil.html">00057</a> <span class="keyword">class </span><a class="code" href="classGfxFilterUtil.html">GfxFilterUtil</a> {
00058    <span class="keyword">public</span>:
00059 
00074       <span class="keyword">static</span> <span class="keywordtype">double</span> dist( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> k,
00075             <span class="keywordtype">int</span>* x, <span class="keywordtype">int</span>* y );
00076 
00090       <span class="keyword">static</span> <span class="keywordtype">double</span> costFunction( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span>* x, <span class="keywordtype">int</span>* y);
00091 
00104       <span class="keyword">template</span>&lt;<span class="keyword">class</span> INT_SEQUENCE, <span class="keyword">class</span> XYHELPER, <span class="keyword">class</span> POINT_ITERATOR&gt;
00105          <span class="keyword">static</span> <span class="keywordtype">double</span> getTotalError( 
00106                <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00107                <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00108                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00109                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd );
00110 
00111 
00128       <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE,
00129       <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
00130          <span class="keyword">static</span> <span class="keywordtype">double</span> filter(
00131                INT_PUSH_BACKABLE&amp; outIndeces,
00132                <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00133                <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00134                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00135                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00136                <span class="keywordtype">int</span>   W, 
00137                <span class="keywordtype">int</span>   iterations,
00138                <span class="keywordtype">int</span>   maxSizeOfSegment );
00139 
00156       <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE,
00157       <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
00158          <span class="keyword">static</span> <span class="keywordtype">void</span> iterationFilter(
00159                INT_PUSH_BACKABLE&amp; outIndeces,
00160                <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00161                <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00162                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00163                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00164                <span class="keywordtype">int</span>   W, 
00165                <span class="keywordtype">int</span>   iterations,
00166                <span class="keywordtype">int</span>   maxSizeOfSegment );
00183       <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE,
00184       <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
00185          <span class="keyword">static</span> <span class="keywordtype">void</span> polygonSplitFilter(
00186                INT_PUSH_BACKABLE&amp; outIndeces,
00187                <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00188                <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00189                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00190                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00191                <span class="keywordtype">int</span>   W, 
00192                <span class="keywordtype">int</span>   maxSizeOfSegment );
00193 
00213       <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE, 
00214       <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
00215          <span class="keyword">static</span> <span class="keywordtype">void</span> runFilter(
00216                INT_PUSH_BACKABLE&amp; outIndeces,
00217                <span class="keyword">const</span> INT_SEQUENCE&amp; rsPath,
00218                <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00219                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00220                <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00221                <span class="keywordtype">int</span>   W );
00222 };
00223 
00224 <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE, 
00225    <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
<a name="l00226"></a><a class="code" href="classGfxFilterUtil.html#e3">00226</a>    <span class="keywordtype">double</span> <a class="code" href="classGfxFilterUtil.html#e3">GfxFilterUtil::filter</a>(
00227          INT_PUSH_BACKABLE&amp; outIndeces,
00228          <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00229          <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00230          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00231          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00232          <span class="keywordtype">int</span> W = 9, 
00233          <span class="keywordtype">int</span> iterations = 10,
00234          <span class="keywordtype">int</span> maxSizeOfSegment = 1000 ) {
00235 
00236       <span class="comment">// Help confused users set good values if they try to set bad</span>
00237       <span class="comment">// values so that we dont give realy poor results..</span>
00238       <span class="keywordflow">if</span>( W &lt; 3 ) {
00239          W = 3;
00240       }
00241       <span class="keywordflow">if</span>( iterations &lt;= 1) {
00242          iterations = 1;      
00243       }
00244       <span class="keywordflow">if</span>( maxSizeOfSegment &lt; 10 ) {
00245          maxSizeOfSegment = 10;
00246       }
00247 
00248       <span class="comment">// Let iterationFilter do its iterative work.   </span>
00249       <a class="code" href="classGfxFilterUtil.html#e4">GfxFilterUtil::iterationFilter</a>( 
00250             outIndeces, 
00251             referencePath, 
00252             xyhelper,
00253             pointsBegin,
00254             pointsEnd,
00255             W,
00256             iterations,
00257             maxSizeOfSegment );
00258 
00259       <span class="comment">// Return the error for this polygon</span>
00260       <span class="keywordflow">return</span> <a class="code" href="classGfxFilterUtil.html#e2">GfxFilterUtil::getTotalError</a>(
00261             outIndeces,
00262             xyhelper,
00263             pointsBegin, pointsEnd);
00264 
00265    }
00266 
00267 <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE, 
00268    <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
<a name="l00269"></a><a class="code" href="classGfxFilterUtil.html#e4">00269</a>    <span class="keywordtype">void</span> <a class="code" href="classGfxFilterUtil.html#e4">GfxFilterUtil::iterationFilter</a>(
00270          INT_PUSH_BACKABLE&amp; outIndeces,
00271          <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00272          <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00273          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00274          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00275          <span class="keywordtype">int</span> W, 
00276          <span class="keywordtype">int</span> iterations,
00277          <span class="keywordtype">int</span> maxSizeOfSegment ) {
00278 
00279       <span class="comment">// Calculate the error so that we might cut the search</span>
00280       <span class="comment">// after just one run if it dosent improve the path.</span>
00281       <span class="keywordtype">double</span> <a class="code" href="MC2Logging_8h.html#a16">error</a> = <a class="code" href="classGfxFilterUtil.html#e2">GfxFilterUtil::getTotalError</a>(
00282             referencePath,
00283             xyhelper,
00284             pointsBegin, pointsEnd);
00285 
00286       <span class="comment">// Use to indeces vectors so that we can swap between them</span>
00287       <span class="comment">// after each run of the algorithm and use out data as </span>
00288       <span class="comment">// in data in the next run.</span>
00289       <a class="code" href="classvector.html">vector&lt;int&gt;</a> indecesB;
00290       <a class="code" href="classvector.html">vector&lt;int&gt;</a> indecesA;
00291 
00292       <span class="comment">// Put in data in indecesB for the first run to work.</span>
00293       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00294             it = referencePath.begin();
00295             it != referencePath.end(); ++it ) {
00296          indecesA.push_back( *it );
00297       }
00298       <span class="comment">// Iterate over indata until ( i &lt; iterations ) or local</span>
00299       <span class="comment">// optimum found. ( temp_error == error )</span>
00300       <span class="keywordtype">int</span> i = 0;
00301       <span class="keywordflow">while</span>( i &lt; iterations ) {
00302          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"GfxFilterUtil::iterationFilter i:"</span> &lt;&lt; i &lt;&lt; endl;
00303          <span class="comment">// Swap indata and out data.</span>
00304          indecesA.swap( indecesB );
00305          indecesA.clear();
00306          i++;
00307          <a class="code" href="classGfxFilterUtil.html#e5">GfxFilterUtil::polygonSplitFilter</a>( 
00308                indecesA, 
00309                indecesB, 
00310                xyhelper,
00311                pointsBegin,
00312                pointsEnd,
00313                W,
00314                maxSizeOfSegment );
00315          <span class="comment">// Calculate the error so that we can break the search if </span>
00316          <span class="comment">// we have reached a local optimum.</span>
00317          <span class="keywordtype">double</span> temp_error = <a class="code" href="classGfxFilterUtil.html#e2">GfxFilterUtil::getTotalError</a>(
00318                indecesA,
00319                xyhelper,
00320                pointsBegin, pointsEnd); 
00321          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"GfxFilterUtil::iterationFilter temp_error:"</span> 
00322                 &lt;&lt; temp_error &lt;&lt; endl;
00323 
00324          <span class="comment">// Break on local optimum.</span>
00325          <span class="keywordflow">if</span>( temp_error &gt;= error ) {
00326             i = iterations;
00327          }
00328          <a class="code" href="MC2Logging_8h.html#a16">error</a> = temp_error;
00329       }
00330       <span class="comment">// Send the resulting path back.</span>
00331       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00332             it = indecesA.begin(); 
00333             it != indecesA.end(); ++it ) {
00334          outIndeces.push_back( *it );
00335       }  
00336    }
00337 
00338 <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE, 
00339          <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
<a name="l00340"></a><a class="code" href="classGfxFilterUtil.html#e5">00340</a>    <span class="keywordtype">void</span> <a class="code" href="classGfxFilterUtil.html#e5">GfxFilterUtil::polygonSplitFilter</a>(
00341          INT_PUSH_BACKABLE&amp; outIndeces,
00342          <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00343          <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00344          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00345          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00346          <span class="keywordtype">int</span> W, 
00347          <span class="keywordtype">int</span> maxSizeOfSegment ) {
00348       <span class="comment">// Calculate how big the referencePathLength is. That is how many </span>
00349       <span class="comment">// vertexes the refferencePath consists of.   </span>
00350       <span class="keywordtype">int</span> M = 0;
00351       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00352             it = referencePath.begin();
00353             it != referencePath.end(); ++it ) {
00354          M++;
00355       }
00356 
00357       <span class="comment">// Create and init the reference path (index values in this array).</span>
00358       <span class="comment">// gets the indexes from a INT_SEQUENCE and puts them in a int array.</span>
00359       <span class="keywordtype">int</span>* rsPath = <span class="keyword">new</span> <span class="keywordtype">int</span>[M];
00360       <span class="keywordtype">int</span> M_index = 0;
00361       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00362             it = referencePath.begin();
00363             it != referencePath.end(); ++it ) {
00364          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"Ref path:"</span> &lt;&lt; *it &lt;&lt; endl;
00365          rsPath[M_index] = *it;
00366          ++M_index;
00367       }
00368 
00369       <span class="comment">// Points to begin and end getting x and y values from.   </span>
00370       POINT_ITERATOR localPointsBegin = pointsBegin;
00371       POINT_ITERATOR localPointsEnd = pointsBegin;
00372 
00373       <span class="comment">// Pushback the first point in the path ( it is always 0 ) so that</span>
00374       <span class="comment">// we dont have to worry about that later when we dont pushback the </span>
00375       <span class="comment">// first one in every segment. If we would pushback the first one </span>
00376       <span class="comment">// in every segment that would overlapp with the last one in the </span>
00377       <span class="comment">// pervious segment.</span>
00378       outIndeces.push_back( 0 );
00379 
00380       <span class="comment">// Init important split values.</span>
00381       <span class="keywordtype">int</span> startCoord = 0;
00382       <span class="keywordtype">int</span> endCoord = 0;
00383       <span class="keywordtype">int</span> t = 0;
00384       <span class="keywordtype">int</span> old_t = 0;
00385       <span class="comment">// Do this until we reach the end of the path.</span>
00386       <span class="keywordflow">while</span>( endCoord &lt; rsPath[ M - 1 ]) {
00387          endCoord += maxSizeOfSegment;
00388          <span class="keywordflow">if</span>( endCoord &gt; rsPath[ M - 1 ] ) {
00389             endCoord = rsPath[ M - 1 ];
00390          }
00391          <span class="comment">// Search for the next point that is in that rsPath.</span>
00392          <span class="comment">// And use that point as the last point in this split.</span>
00393          <span class="keywordflow">while</span>( rsPath[ t ] &lt; endCoord &amp;&amp; t &lt; M - 1 ) { t++; }
00394          endCoord = rsPath[ t ];
00395 
00396          <span class="comment">// Select all the indeces that we want to use in this </span>
00397          <span class="comment">// split.</span>
00398          <a class="code" href="classvector.html">vector&lt;int&gt;</a> tempRSPath;
00399          <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = old_t; i &lt;= t; i++ ) {
00400             tempRSPath.push_back( rsPath[ i ] - startCoord );
00401          }
00402 
00403 
00404          <span class="comment">// Select all the x and y values that we want to use in this</span>
00405          <span class="comment">// split.</span>
00406          <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = startCoord; i &lt;= endCoord; i++) {
00407             localPointsEnd++;
00408          }
00409          <a class="code" href="classvector.html">vector&lt;int&gt;</a> tempIndeces;
00410          <span class="comment">// Run the filter on this part of the polygon.</span>
00411          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"Running filter on spilt start: "</span> &lt;&lt; startCoord
00412                 &lt;&lt; <span class="stringliteral">" end: "</span> &lt;&lt; endCoord &lt;&lt; endl;
00413          <a class="code" href="classGfxFilterUtil.html#e6">GfxFilterUtil::runFilter</a>( 
00414                tempIndeces, 
00415                tempRSPath, 
00416                xyhelper, 
00417                localPointsBegin, 
00418                localPointsEnd, 
00419                W );
00420 
00421          <span class="keyword">typename</span> INT_SEQUENCE::const_iterator it = tempIndeces.begin(); 
00422          it++;      
00423          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"ut: "</span>;
00424          <span class="comment">// Send the resulting part of the path back.</span>
00425          <span class="keywordflow">for</span> ( ; it != tempIndeces.end(); ++it ) {
00426             outIndeces.push_back( *it + startCoord );
00427             <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; *it &lt;&lt; <span class="stringliteral">" "</span>; 
00428          }
00429          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; endl;
00430 
00431          <span class="comment">// Init some values for tha next part of the polygon.</span>
00432          localPointsBegin = --localPointsEnd;
00433          startCoord = endCoord;
00434          old_t = t;
00435       }
00436       <span class="comment">// Clean up</span>
00437       <span class="keyword">delete</span>[] rsPath;
00438       rsPath=NULL;
00439    }
00440 <span class="keyword">template</span>&lt;<span class="keyword">class </span>INT_PUSH_BACKABLE, <span class="keyword">class </span>INT_SEQUENCE, 
00441    <span class="keyword">class </span>XYHELPER, <span class="keyword">class </span>POINT_ITERATOR&gt;
<a name="l00442"></a><a class="code" href="classGfxFilterUtil.html#e6">00442</a>    <span class="keywordtype">void</span> <a class="code" href="classGfxFilterUtil.html#e6">GfxFilterUtil::runFilter</a>( 
00443          INT_PUSH_BACKABLE&amp; outIndeces,
00444          <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath, 
00445          <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00446          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00447          <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd,
00448          <span class="keywordtype">int</span> W )
00449 {
00450    <span class="comment">// If the user is stupid and wants to use a W that is to small,</span>
00451    <span class="comment">// we will help him/her and correct the errors of it's ways.</span>
00452    <span class="keywordflow">if</span>( W &lt; 3 ) {
00453       W = 3;
00454    }
00455 
00456    <span class="comment">// Calculate how big N is. That is how many vertexes the </span>
00457    <span class="comment">// original polygon consists of.</span>
00458    <span class="keywordtype">int</span> N = 0;
00459    <span class="keywordflow">for</span>( POINT_ITERATOR it = pointsBegin;
00460          it != pointsEnd; ++it ) {
00461       N++;
00462    }
00463 
00464    <span class="keywordflow">if</span>( N &lt;= 2 ) {
00465       outIndeces.push_back( 0 );
00466       <span class="keywordflow">if</span>( N == 2 ) {
00467          outIndeces.push_back( 1 );
00468          return ;
00469       }
00470       return ;
00471    }
00472 
00473    <span class="comment">// Calculate how big the referencePathLength is. That is how many </span>
00474    <span class="comment">// vertexes the refferencePath consists of.   </span>
00475    <span class="keywordtype">int</span> M = 0;
00476    <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00477          it = referencePath.begin();
00478          it != referencePath.end(); ++it ) {
00479       M++;
00480    }
00481 
00482    <span class="comment">// Create and init the reference path (index values in this array).</span>
00483    <span class="comment">// gets the indexes from a INT_SEQUENCE and puts them in a int array.</span>
00484    <span class="keywordtype">int</span>* rsPath = <span class="keyword">new</span> <span class="keywordtype">int</span>[M];
00485    <span class="keywordtype">int</span> M_index = 0;
00486    <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator 
00487          it = referencePath.begin();
00488          it != referencePath.end(); ++it ) {
00489       rsPath[M_index] = *it;
00490       ++M_index;
00491    }
00492 
00493    <a class="code" href="config_8h.html#a6">DEBUG4</a>(
00494    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Path before DP: "</span>;
00495    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; M; i++ ) {
00496       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; rsPath[i] &lt;&lt; <span class="stringliteral">" "</span>;
00497    }
00498    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; endl;
00499    );
00500 
00501    <span class="comment">// Precalculates the boundaries for the bounding corridor.</span>
00502    <span class="comment">// More can be read about this in Kolesnikovs paper. L, R, </span>
00503    <span class="comment">// T, B stands for Left, Right, Top, Bottom just as one</span>
00504    <span class="comment">// might suspect.</span>
00505    <span class="keywordtype">int</span> c1 = W / 2;
00506    <span class="keywordtype">int</span> c2 = W - c1;
00507 
00508    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Creating bounds."</span> &lt;&lt; endl;
00509 
00510    <span class="comment">// Create and fill L with bounding coords.</span>
00511    <span class="keywordtype">int</span>* L = <span class="keyword">new</span> <span class="keywordtype">int</span>[ M + 1 ];
00512    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = 1; m &lt; M; m++ ) {
00513       <span class="keywordflow">if</span>( m &lt; c1 ) {
00514          L[ m ] = m;
00515       } <span class="keywordflow">else</span> {
00516          L[ m ] = max( m, rsPath[ m - c1 ] );
00517       }
00518    }
00519    L[ 0 ] = 0;
00520    L[ M ] = N;
00521 
00522    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"L done."</span> &lt;&lt; endl;
00523 
00524    <span class="comment">// Create and fill R with bounding coords.</span>
00525    <span class="keywordtype">int</span>* R = <span class="keyword">new</span> <span class="keywordtype">int</span>[ M + 1];
00526    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = 1; m &lt; M; m++ ) {
00527       <span class="keywordflow">if</span>(m &lt; M - c2){
00528          R[ m ] = min( N - ( M - m ), rsPath[ m + c2 ] - 1 );
00529       } <span class="keywordflow">else</span> {
00530          R[ m ] = N - ( M - m );
00531       }
00532    } 
00533    R[ 0 ] = 0;
00534    R[ M ] = N;
00535 
00536    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"R done."</span> &lt;&lt; endl;
00537 
00538    <span class="comment">// Create and fill B with bounding coords.</span>
00539    <span class="keywordtype">int</span>* B = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N + 1];
00540    <span class="keywordtype">int</span> t = 0;
00541    <span class="keywordtype">int</span> m = 0;
00542    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> n = 1; n &lt; N; n++ ) {
00543       <span class="keywordflow">if</span>( n &gt;= rsPath[ t ] ) {
00544          m = ++t - c1 - ( W % 2 );
00545          <span class="keywordflow">if</span>( m &lt; 1 ) {
00546             m = 1;
00547          }
00548          <span class="keywordflow">if</span>( m &gt;= N ) {
00549             m = N - 1;
00550          }
00551       }
00552       <span class="keywordflow">if</span>( m &lt; n - ( N - M ) ) {
00553          m = n - ( N - M );
00554       }                
00555       B[ n ] = m;
00556    }
00557    B[ 0 ] = 0;
00558    B[ N ] = M;
00559 
00560    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"B done."</span> &lt;&lt; endl;
00561 
00562    <span class="comment">// Create and fill T with bounding coords.</span>
00563    <span class="keywordtype">int</span>* T = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N + 1 ];
00564    t = 0;
00565    m = 0;
00566    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> n = 1; n &lt; N; n++ ) {
00567       <span class="keywordflow">if</span>( n &gt;= rsPath[ t ] ) {
00568          m = ++t + c1 - 1;
00569          <span class="keywordflow">if</span>( m &gt;= M ) {
00570             m = M - 1;
00571          }
00572          <span class="keywordflow">if</span>( m &gt; n ) {
00573             t--;
00574             m = n;
00575          }
00576       }
00577       T[ n ] = m;
00578    }
00579    T[ 0 ] = 0;
00580    T[ N ] = M;
00581 
00582    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"T done."</span> &lt;&lt; endl;
00583 
00584    <span class="comment">// Arrays to store the points x and y values in.</span>
00585    <span class="keywordtype">int</span>* x = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N + 1 ];
00586    <span class="keywordtype">int</span>* y = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N + 1 ];
00587    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= N; i++) {
00588       x[ i ] = 0;
00589       y[ i ] = 0;
00590    }
00591    <span class="comment">// Array to store precalculated approximation error values in.</span>
00592    <span class="keywordtype">double</span>* v = <span class="keyword">new</span> <span class="keywordtype">double</span>[ N + 1 ];
00593    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= N; i++) {
00594       v[ i ] = 0;
00595    }
00596 
00597    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Put the x's and y's in arrays for later use."</span> &lt;&lt; endl;
00598 
00599    <span class="comment">// Put the x's and y's in arrays for later use.</span>
00600    <span class="keywordtype">int</span> i = 0;
00601    <span class="keywordflow">for</span>( POINT_ITERATOR it = pointsBegin;
00602          it != pointsEnd;
00603          ++it ) {
00604       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"x "</span> &lt;&lt; xyhelper.getX(*it) &lt;&lt; 
00605          <span class="stringliteral">" y "</span> &lt;&lt; xyhelper.getY(*it) &lt;&lt; endl;      
00606       x[ i ] = xyhelper.getX(*it);
00607       y[ i++ ] = xyhelper.getY(*it);
00608    }
00609 
00610    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Creating statespace."</span> &lt;&lt; endl;
00611 
00612    <span class="comment">// Create statespace array. In this array we will keep track of </span>
00613    <span class="comment">// the costs of smaler instances of the current problem. That is</span>
00614    <span class="comment">// smaller M and N values, the errors for the smaller instances</span>
00615    <span class="comment">// are used to calculate the larger instances with dynamic</span>
00616    <span class="comment">// programming.</span>
00617    <span class="keywordtype">double</span>** D = <span class="keyword">new</span> <span class="keywordtype">double</span>*[ N + 1 ];
00618    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt;= N; ++i ) {
00619       D[ i ] = <span class="keyword">new</span> <span class="keywordtype">double</span>[ W + 1 ]; 
00620    }
00621 
00622    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Creating parrent array."</span> &lt;&lt; endl;  
00623 
00624    <span class="comment">// Create parrent array. This is used for backtracking after</span>
00625    <span class="comment">// the dp part is done. Backtracking is done from A[ N ][ 0 ] </span>
00626    <span class="comment">// to A[ 0 ][ 0 ].</span>
00627    <span class="keywordtype">int</span>** A = <span class="keyword">new</span> <span class="keywordtype">int</span>*[ N + 1 ];
00628    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt;= N; ++i ) {
00629       A[ i ] = <span class="keyword">new</span> <span class="keywordtype">int</span>[ W + 1 ]; 
00630    }
00631 
00632    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"N = "</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">" M = "</span> &lt;&lt; M &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; endl;
00633 
00634    <span class="comment">// Init the statespace array, everything inside should be 0.</span>
00635    <span class="comment">// The same goes for the A (parrent) array.</span>
00636    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> n = 0; n &lt;= N; n++ ) {
00637       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> w = 0; w &lt;= W; w++ ) {
00638          D[ n ][ w ] = 0;
00639          A[ n ][ w ] = 0;
00640       }
00641    }
00642 
00643    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"DP run."</span> &lt;&lt; endl;
00644 
00645    <span class="comment">// Reduced-search algorithm start, a good description of this </span>
00646    <span class="comment">// can be found in P2.</span>
00647    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> n = 2; n &lt;= N; n++ ) {
00648       <span class="comment">// Precalculate the costFunction before we enter the "m" loop</span>
00649       <span class="comment">// and gain speed this way.</span>
00650       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = L[ B[ n ] - 1 ]; j &lt;= n - 1; j++ ) {
00651          v[ n - j ] = <a class="code" href="classGfxFilterUtil.html#e1">costFunction</a>( j, n, x, y );
00652       }
00653       <span class="comment">// Loop between bottom and top of the corridor.</span>
00654       <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = B[ n ]; m &lt;= T[ n ]; m++ ) {
00655          <span class="keywordtype">double</span> cmin = DBL_MAX;
00656          <span class="keywordtype">int</span> jmin = -1;
00657          <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = L[ m - 1 ]; j &lt;= min( n - 1, R[ m - 1 ] ); j++ ) {
00658             <span class="comment">// "- B[ j ]" is used to puch the size of D down to N * W</span>
00659             <span class="comment">// instead  of N * M that would be needed if we used </span>
00660             <span class="comment">// D[ j ][ m - 1 ] when writing to and reading from the </span>
00661             <span class="comment">// statespace.</span>
00662             <span class="comment">// What we do here is calculate the cost of paths that are </span>
00663             <span class="comment">// longer and loger as we progres in the statespace untill </span>
00664             <span class="comment">// we find a path that is M long. That is when we reach the</span>
00665             <span class="comment">// end of the search in the statespace array and backtracks </span>
00666             <span class="comment">// to see what path was the minimal one.</span>
00667             <span class="keywordtype">double</span> c = D[ j ][ m - 1 - B[ j ] ] + v[ n - j ];
00668             <span class="keywordflow">if</span>( c &lt; cmin ) {
00669                cmin = c;
00670                jmin = j;
00671             }
00672          }
00673          <span class="comment">// again "- B[ n ]" is used to keep size of both A and D down.</span>
00674          <span class="comment">// A is used to keep track of al the j indeces that got us to </span>
00675          <span class="comment">// where we are in the end. A and the values keept inside will</span>
00676          <span class="comment">// help us find the correct way from end to start when we </span>
00677          <span class="comment">// backtrack. </span>
00678          D[ n ][ m - B[ n ] ] = cmin;
00679          A[ n ][ m - B[ n ] ] = jmin;
00680          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; D[n][m-B[n]] &lt;&lt; <span class="stringliteral">" "</span>;
00681       }
00682       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; endl;
00683    }
00684 
00685    <span class="comment">// Backtracking to find resulting path in A.</span>
00686    <span class="comment">// Create array to temporary store the new path.</span>
00687    <span class="keywordtype">int</span>* H = <span class="keyword">new</span> <span class="keywordtype">int</span>[ M ];
00688    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = 0; m &lt; M; ++m ) {
00689       H[ m ] = 0;
00690    }
00691    <span class="comment">// Backtracking begins at A[ N ][ 0 ] (that would have been A[ N ][ M ]</span>
00692    <span class="comment">// if we dident use "- B[ n ]" to reduce memmory usage).</span>
00693    H[ M - 1 ] = A[ N ][ 0 ];
00694    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = M - 1; m &gt;= 1; m-- ) {
00695       H[ m - 1 ] = A[ H[ m ] ][ m - B[ H[ m ] ] ];
00696       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; H[ m ] &lt;&lt; <span class="stringliteral">" "</span>;
00697    }
00698    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; endl;
00699    <span class="comment">// The first and last point in the path needs to be 0 and N - 1.</span>
00700    H[ 0 ] = 0;
00701    H[ M - 1 ] = N - 1;
00702 
00703    <span class="comment">// Send the indeces that the backtracking resulted in back using</span>
00704    <span class="comment">// push_back.</span>
00705    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Resulting path: "</span>;
00706    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> m = 0; m &lt; M ; m++ ) {
00707       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; H[ m ] &lt;&lt; <span class="stringliteral">" "</span>;
00708       outIndeces.push_back( H[ m ] );
00709    }
00710    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; endl; 
00711 
00712    <span class="comment">// Due to "- B[ n ]" the total error will be found in D[ N ][ 0 ] and</span>
00713    <span class="comment">// not in D[ N ][ M ] as one could expect.</span>
00714    <span class="comment">//double error = D[ N ][ 0 ];</span>
00715 
00716    <span class="comment">// Reduced-search algorithm end</span>
00717 
00718    <span class="comment">// Delete arrays.</span>
00719    <span class="keyword">delete</span>[] H;
00720 
00721    <span class="keyword">delete</span>[] x;
00722    <span class="keyword">delete</span>[] y;
00723 
00724    <span class="keyword">delete</span>[] v;
00725 
00726    <span class="keyword">delete</span>[] rsPath;
00727 
00728    <span class="keyword">delete</span>[] L;
00729    <span class="keyword">delete</span>[] R;
00730    <span class="keyword">delete</span>[] B;
00731    <span class="keyword">delete</span>[] T;
00732 
00733    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt;= N; i++ ) {
00734       <span class="keyword">delete</span>[] A[ i ];
00735       <span class="keyword">delete</span>[] D[ i ];
00736    }
00737    <span class="keyword">delete</span>[] A;
00738    <span class="keyword">delete</span>[] D;
00739 
00740    <span class="comment">// Delete complete.</span>
00741 }
00742 
00743 <span class="keyword">inline</span> <span class="keywordtype">double</span> 
<a name="l00744"></a><a class="code" href="classGfxFilterUtil.html#e1">00744</a> <a class="code" href="classGfxFilterUtil.html#e1">GfxFilterUtil::costFunction</a>( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span>* x, <span class="keywordtype">int</span>* y)
00745 {
00746    <span class="keywordtype">double</span> cost = 0;
00747    <span class="keywordflow">if</span>( i &gt; j ){
00748       <span class="keywordtype">int</span> temp = i;
00749       i = j;
00750       j = temp;
00751    }
00752    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> k = i; k &lt; j; k++ ){
00753       cost += <a class="code" href="classGfxUtility.html#e9">GfxUtility::closestDistVectorToPoint</a>(
00754             x[ i ], y[ i ], x[ j ], y[ j ], x[ k ], y[ k ], 1 ) + 
00755          <a class="code" href="classGfxUtility.html#e0">GfxUtility::squareP2Pdistance_linear</a>(
00756                x[ i ], y[ i ], x[ j ], y[ j ], 1 ) / 2;
00757    }
00758    <span class="keywordflow">return</span> cost;
00759 }
00760 
00761 <span class="keyword">template</span>&lt;<span class="keyword">class</span> INT_SEQUENCE, <span class="keyword">class</span> XYHELPER, <span class="keyword">class</span> POINT_ITERATOR&gt;
<a name="l00762"></a><a class="code" href="classGfxFilterUtil.html#e2">00762</a> <span class="keywordtype">double</span> <a class="code" href="classGfxFilterUtil.html#e2">GfxFilterUtil::getTotalError</a>( 
00763       <span class="keyword">const</span> INT_SEQUENCE&amp; referencePath,
00764       <span class="keyword">const</span> XYHELPER&amp; xyhelper,
00765       <span class="keyword">const</span> POINT_ITERATOR&amp; pointsBegin,
00766       <span class="keyword">const</span> POINT_ITERATOR&amp; pointsEnd )
00767 {
00768 
00769    <span class="comment">// Calculate how big N is. That is how many vertexes the </span>
00770    <span class="comment">// original polygon consists of.</span>
00771    <span class="keywordtype">int</span> N = 0;
00772    <span class="keywordflow">for</span>( POINT_ITERATOR it = pointsBegin;
00773          it != pointsEnd; ++it ) {
00774       N++;
00775    }
00776 
00777    <span class="comment">// This one seems unnecessary.</span>
00778    <span class="comment">// Array to store precalculated approximation error values in.</span>
00779    <span class="comment">//double* v = new double[ N ];</span>
00780    <span class="comment">//for(int i = 0; i != N; i++) {</span>
00781    <span class="comment">//   v[ i ] = 0;</span>
00782    <span class="comment">//}</span>
00783 
00784    <span class="comment">// Arrays to store the x and y coords in.</span>
00785    <span class="keywordtype">int</span>* x = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N ];
00786    <span class="keywordtype">int</span>* y = <span class="keyword">new</span> <span class="keywordtype">int</span>[ N ]; 
00787    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i != N; i++) {
00788       x[ i ] = 0;
00789       y[ i ] = 0;
00790    }
00791 
00792    <span class="comment">//Put the x's and y's in arrays for later use.</span>
00793    <span class="keywordtype">int</span> i = 0;
00794    <span class="keywordflow">for</span>( POINT_ITERATOR it = pointsBegin;
00795          it != pointsEnd;
00796          ++it ) {
00797       x[ i ] = xyhelper.getX(*it);
00798       y[ i++ ] = xyhelper.getY(*it);
00799    }
00800 
00801    <span class="comment">// Calculate how big the referencePathLength is. That is how many </span>
00802    <span class="comment">// vertexes the referencePath consists of.</span>
00803    <span class="keywordtype">int</span> M = 0;
00804    <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator it = referencePath.begin();
00805          it != referencePath.end(); ++it ) {
00806       M++;
00807    }
00808    <span class="comment">// Create and init the reference path (index values in this array).</span>
00809    <span class="comment">// gets the indexes from a INT_SEQUENCE and puts them in a int array.</span>
00810    <span class="keywordtype">int</span>* rsPath = <span class="keyword">new</span> <span class="keywordtype">int</span>[M];
00811    <span class="keywordtype">int</span> M_index = 0;
00812    <span class="keywordflow">for</span> ( <span class="keyword">typename</span> INT_SEQUENCE::const_iterator it = referencePath.begin();
00813          it != referencePath.end(); ++it ) {
00814       rsPath[M_index] = *it;
00815       ++M_index;
00816    }
00817 
00818    <span class="keywordtype">double</span> totalError = 0;
00819 
00820    <span class="comment">// Loop through the approximation.</span>
00821    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 1; i &lt; M; i++ ) {
00822       <span class="comment">// Calculate the cost for each an d everyone of the new lines</span>
00823       <span class="comment">// in the approximated polygon. Sum them up and return the</span>
00824       <span class="comment">// total error.</span>
00825       totalError += <a class="code" href="classGfxFilterUtil.html#e1">costFunction</a>( rsPath[i - 1], rsPath[ i ], x, y );
00826    }
00827    <span class="comment">// Clean up.</span>
00828    <span class="keyword">delete</span>[] x;
00829    x=NULL;
00830    <span class="keyword">delete</span>[] y;
00831    y=NULL;
00832    <span class="keyword">delete</span>[] rsPath;
00833    rsPath=NULL;
00834 
00835    <span class="keywordflow">return</span> totalError;
00836 }
00837 
00838 
<a name="l00839"></a><a class="code" href="classMC2CoordXYHelper.html">00839</a> <span class="keyword">class </span><a class="code" href="classMC2CoordXYHelper.html">MC2CoordXYHelper</a> {
00840    <span class="keyword">public</span>:
<a name="l00841"></a><a class="code" href="classMC2CoordXYHelper.html#a0">00841</a>       <span class="keyword">inline</span> <a class="code" href="Types_8h.html#a22">int32</a> getX(<span class="keyword">const</span> <a class="code" href="classMC2Coordinate.html">MC2Coordinate</a>&amp; coord)<span class="keyword"> const </span>{
00842          <span class="keywordflow">return</span> <a class="code" href="Types_8h.html#a22">int32</a>( <a class="code" href="RouteRequestData_8h.html#a3a0">coord</a>.<a class="code" href="classMC2Coordinate.html#o1">lon</a> * 
00843                GfxUtility::getCoslat( <a class="code" href="RouteRequestData_8h.html#a3a0">coord</a>.<a class="code" href="classMC2Coordinate.html#o0">lat</a>, <a class="code" href="RouteRequestData_8h.html#a3a0">coord</a>.<a class="code" href="classMC2Coordinate.html#o0">lat</a> ) );
00844       }
00845 
<a name="l00846"></a><a class="code" href="classMC2CoordXYHelper.html#a1">00846</a>       <span class="keyword">inline</span> <a class="code" href="Types_8h.html#a22">int32</a> getY(<span class="keyword">const</span> <a class="code" href="classMC2Coordinate.html">MC2Coordinate</a>&amp; coord)<span class="keyword"> const </span>{
00847          <span class="keywordflow">return</span> <a class="code" href="RouteRequestData_8h.html#a3a0">coord</a>.<a class="code" href="classMC2Coordinate.html#o0">lat</a>;
00848       }
00849 };
00850 
00851 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:46 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
