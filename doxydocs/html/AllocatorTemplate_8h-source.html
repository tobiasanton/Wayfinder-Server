<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: AllocatorTemplate.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Server</a>&nbsp;/&nbsp;<a class="el" href="dir_000005.html">Shared</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">include</a></div>
<h1>AllocatorTemplate.h</h1><a href="AllocatorTemplate_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (c) 1999 - 2010, Vodafone Group Services Ltd</span>
00003 <span class="comment">All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
00008 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
00009 <span class="comment">    * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
00010 <span class="comment"></span>
00011 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#ifndef ALLOCATORTEMPLATES_H</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define ALLOCATORTEMPLATES_H</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#include "<a class="code" href="DeleteHelpers_8h.html">DeleteHelpers.h</a>"</span>
00018 <span class="preprocessor">#include "<a class="code" href="STLUtility_8h.html">STLUtility.h</a>"</span>
00019 <span class="preprocessor">#include "<a class="code" href="ArrayTools_8h.html">ArrayTools.h</a>"</span>
00020 
00021 <span class="preprocessor">#if defined (__GNUC__) &amp;&amp; __GNUC__ &gt; 2</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ext/slist&gt;</span>
00023 <span class="keyword">using</span> <span class="keyword">namespace </span>__gnu_cxx;
00024 <span class="preprocessor">#else</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;slist&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;map&gt;</span>
00029 
00030 <span class="keyword">class </span><a class="code" href="classGenericMap.html">GenericMap</a>;
00031 
<a name="l00032"></a><a class="code" href="classAbstractMC2Allocator.html">00032</a> <span class="keyword">class </span><a class="code" href="classAbstractMC2Allocator.html">AbstractMC2Allocator</a> {
00033 <span class="keyword">public</span>:
00034 
<a name="l00035"></a><a class="code" href="classAbstractMC2Allocator.html#a0">00035</a>    <span class="keyword">virtual</span> ~<a class="code" href="classAbstractMC2Allocator.html">AbstractMC2Allocator</a>() {};
00036    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceArrayTool.html#a0">reallocate</a>(<span class="keywordtype">int</span> n) = 0;
00037    <span class="keyword">virtual</span> <a class="code" href="Types_8h.html#a21">uint32</a> getBlockSize() <span class="keyword">const </span>= 0;
00038    <span class="keyword">virtual</span> <a class="code" href="Types_8h.html#a21">uint32</a> getTotalNbrElements() <span class="keyword">const </span>= 0;
00039 };
00040 
<a name="l00044"></a><a class="code" href="classMC2ArrayAllocator.html">00044</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classMC2ArrayAllocator.html">MC2ArrayAllocator</a> : <span class="keyword">public</span> <a class="code" href="classAbstractMC2Allocator.html">AbstractMC2Allocator</a> {
00045 <span class="keyword">public</span>:
00046    
<a name="l00047"></a><a class="code" href="classMC2ArrayAllocator.html#w0">00047</a>    <span class="keyword">typedef</span> <a class="code" href="classmap.html">map&lt;T*, int&gt;</a> <a class="code" href="classmap.html">singeAllocMap_t</a>;
00048 
<a name="l00049"></a><a class="code" href="classMC2ArrayAllocator.html#a0">00049</a>    <a class="code" href="classMC2ArrayAllocator.html#a0">MC2ArrayAllocator</a>( <span class="keywordtype">int</span> size = 0 ) {
00050       m_warnSingleAlloc = <span class="keyword">false</span>;
00051       m_bigArray = NULL;
00052       <a class="code" href="classMC2ArrayAllocator.html#a4">reallocate</a>( size );
00053    }
00054 
<a name="l00055"></a><a class="code" href="classMC2ArrayAllocator.html#a1">00055</a>    <a class="code" href="classMC2ArrayAllocator.html#a1">~MC2ArrayAllocator</a>() {
00056       <a class="code" href="classMC2ArrayAllocator.html#a4">reallocate</a>(0);
00057    }
00058 
<a name="l00059"></a><a class="code" href="classMC2ArrayAllocator.html#a2">00059</a>    <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2ArrayAllocator.html#a2">getBlockSize</a>()<span class="keyword"> const </span>{
00060       <span class="keywordflow">return</span> m_nbrElementsUsed;
00061    }
00062 
<a name="l00069"></a><a class="code" href="classMC2ArrayAllocator.html#a3">00069</a>    <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2ArrayAllocator.html#a3">getTotalNbrElements</a>()<span class="keyword"> const </span>{
00070       <a class="code" href="Types_8h.html#a21">uint32</a> sum = <a class="code" href="classMC2ArrayAllocator.html#a2">getBlockSize</a>();
00071       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> singeAllocMap_t::const_iterator it = m_singleAlloc.begin();
00072             it != m_singleAlloc.end();
00073             ++it ) {
00074          sum += it-&gt;second;
00075       }
00076       <span class="keywordflow">return</span> sum;
00077    }
00078    
<a name="l00083"></a><a class="code" href="classMC2ArrayAllocator.html#a4">00083</a>    <span class="keywordtype">void</span> <a class="code" href="classMC2ArrayAllocator.html#a4">reallocate</a>( <span class="keywordtype">int</span> n ) {
00084       <span class="comment">// Destroy the single alloc.</span>
00085       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> singeAllocMap_t::iterator it = m_singleAlloc.begin();
00086             it != m_singleAlloc.end();
00087             ++it ) {
00088          <span class="keyword">delete</span> [] it-&gt;first;
00089       }
00090       m_singleAlloc.clear();
00091 
00092       <span class="comment">// Clear and recreate the bigarray</span>
00093       m_nbrElementsUsed = 0;
00094       <span class="keyword">delete</span> [] m_bigArray;
00095       <span class="keywordflow">if</span> ( n ) {
00096          m_bigArray = <span class="keyword">new</span> T[n];
00097       } <span class="keywordflow">else</span> {
00098          m_bigArray = NULL;
00099       }
00100       m_bigArraySize = n;
00101    }
00102 
<a name="l00104"></a><a class="code" href="classMC2ArrayAllocator.html#a5">00104</a>    <span class="keywordtype">void</span> <a class="code" href="classMC2ArrayAllocator.html#a5">setWarnSingleAlloc</a>( <span class="keywordtype">bool</span> warnOrNot ) {
00105       m_warnSingleAlloc = warnOrNot;
00106    }
00107    
<a name="l00113"></a><a class="code" href="classMC2ArrayAllocator.html#a6">00113</a>    T* <a class="code" href="classMC2ArrayAllocator.html#a6">getNewArray</a>( <span class="keywordtype">int</span> size ) {
00114       <span class="keywordflow">if</span> ( size ==  0 ) {
00115          <span class="keywordflow">return</span> NULL;
00116       }
00117       <span class="comment">// Check if there is room in the big array.</span>
00118       <span class="keywordflow">if</span> ( ( m_nbrElementsUsed + size ) &lt;= m_bigArraySize ) {
00119          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"[MC2ARRAY]: Using bigbuf ("</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00120          T* oldPtr = m_bigArray + m_nbrElementsUsed;
00121          m_nbrElementsUsed += size;
00122          <span class="keywordflow">return</span> oldPtr;
00123       } <span class="keywordflow">else</span> {
00124          <span class="keywordflow">if</span> ( m_warnSingleAlloc ) {
00125             <a class="code" href="MC2Logging_8h.html#a0">mc2log</a> &lt;&lt; <a class="code" href="MC2Logging_8h.html#a15">warn</a>
00126                    &lt;&lt; <span class="stringliteral">"[MC2ARRAY]: Single alloc("</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
00127          }
00128          <span class="comment">// Have to alloc a new one.</span>
00129          T* newArray = <span class="keyword">new</span> T[size];
00130          m_singleAlloc.insert( make_pair( newArray, size ) );
00131          <span class="keywordflow">return</span> newArray;
00132       }
00133    }
00134    
<a name="l00139"></a><a class="code" href="classMC2ArrayAllocator.html#a7">00139</a>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> S&gt; T* <a class="code" href="classMC2ArrayAllocator.html#a7">addElement</a>( T* array,
00140                                     <span class="keyword">const</span> T&amp; elem, S&amp; nbrElems ) {
00141       <span class="keywordflow">if</span> ( m_warnSingleAlloc ) {
00142          <a class="code" href="MC2Logging_8h.html#a0">mc2log</a> &lt;&lt; <a class="code" href="MC2Logging_8h.html#a15">warn</a> &lt;&lt; <span class="stringliteral">"[MC2ARRAY]: addElement called"</span> &lt;&lt; endl;
00143       }
00144       <span class="keywordflow">if</span> ( <a class="code" href="classMC2ArrayAllocator.html#d0">inBigArray</a>( array ) ) {
00145          <span class="comment">// Get a new or old array</span>
00146          T* tmpArray = <a class="code" href="classMC2ArrayAllocator.html#a6">getNewArray</a>( nbrElems + 1 );
00147          <span class="comment">// Copy old elements.</span>
00148          <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0, n=nbrElems; i &lt; n; ++i ) {
00149             tmpArray[i] = array[i];            
00150          }
00151          <span class="comment">// And add the last one.</span>
00152          tmpArray[ nbrElems++ ] = elem;
00153          array = tmpArray;
00154       } <span class="keywordflow">else</span> {
00155          <span class="comment">// Not in the big array - remove it from the single alloc list</span>
00156          <span class="comment">// and realloc it.</span>
00157          m_singleAlloc.erase( array );
00158          array = <a class="code" href="namespaceArrayTool.html#a1">ArrayTool::addElement</a>( array, elem, nbrElems );
00159          m_singleAlloc.insert( make_pair( array, nbrElems ) );
00160       }
00161       <span class="keywordflow">return</span> array;
00162    }
00163 
00164 <span class="keyword">private</span>:
00165 
<a name="l00166"></a><a class="code" href="classMC2ArrayAllocator.html#d0">00166</a>    <span class="keywordtype">bool</span> <a class="code" href="classMC2ArrayAllocator.html#d0">inBigArray</a>( <span class="keyword">const</span> T* ptr ) {
00167       <span class="keywordflow">if</span> ( ptr == NULL ) {
00168          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00169       } <span class="keywordflow">else</span> {
00170          <span class="keywordflow">return</span> (ptr &gt;= m_bigArray) &amp;&amp; (ptr &lt; (m_bigArray + m_bigArraySize ));
00171       }
00172    }
00173 
<a name="l00174"></a><a class="code" href="classMC2ArrayAllocator.html#r0">00174</a>    <a class="code" href="classmap.html">singeAllocMap_t</a> m_singleAlloc;
<a name="l00175"></a><a class="code" href="classMC2ArrayAllocator.html#r1">00175</a>    T* m_bigArray;
<a name="l00176"></a><a class="code" href="classMC2ArrayAllocator.html#r2">00176</a>    <a class="code" href="Types_8h.html#a21">uint32</a> m_bigArraySize;
<a name="l00177"></a><a class="code" href="classMC2ArrayAllocator.html#r3">00177</a>    <a class="code" href="Types_8h.html#a21">uint32</a> m_nbrElementsUsed;
<a name="l00178"></a><a class="code" href="classMC2ArrayAllocator.html#r4">00178</a>    <span class="keywordtype">bool</span> m_warnSingleAlloc;
00179 };
00180 
<a name="l00188"></a><a class="code" href="classMC2Allocator.html">00188</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classMC2Allocator.html">MC2Allocator</a> : <span class="keyword">public</span> <a class="code" href="classAbstractMC2Allocator.html">AbstractMC2Allocator</a>
00189 {
00190 <span class="keyword">public</span>:
<a name="l00191"></a><a class="code" href="classMC2Allocator.html#w0">00191</a>    <span class="keyword">typedef</span> <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">STLUtility::DualForwardIterator&lt;T, typename slist&lt;T *&gt;</a><a class="code" href="structSTLUtility_1_1DualForwardIterator.html">::iterator</a> &gt; <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">iterator</a>;
<a name="l00192"></a><a class="code" href="classMC2Allocator.html#w1">00192</a>    <span class="keyword">typedef</span> <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">STLUtility::DualForwardIterator&lt;const T, typename slist&lt; T* &gt;</a><a class="code" href="structSTLUtility_1_1DualForwardIterator.html">::const_iterator</a> &gt; <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">const_iterator</a>;
00193 
<a name="l00198"></a><a class="code" href="classMC2Allocator.html#a0">00198</a>    <a class="code" href="classMC2Allocator.html#a0">MC2Allocator</a>(<span class="keywordtype">int</span> n = 0) {
00199       <span class="comment">// Create an array of objects (_not_ of pointers to objects).</span>
00200       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"MC2Allocator(n) enter"</span>);
00201       <span class="comment">//mc2dbg &lt;&lt; "[MC2Allocator]: sizeof(T) == " &lt;&lt; sizeof(T) &lt;&lt; endl;</span>
00202       m_block = NULL;
00203       <a class="code" href="classMC2Allocator.html#a2">initiate</a>(n);
00204       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"MC2Allocator(n) leave"</span>);
00205    };
00206 
<a name="l00210"></a><a class="code" href="classMC2Allocator.html#a1">00210</a>    <span class="keyword">virtual</span> <a class="code" href="classMC2Allocator.html#a1">~MC2Allocator</a>() {
00211       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"~MC2Allocator() enter"</span>);
00212       <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"Deallocate allocator with "</span> &lt;&lt; m_blockAllocated 
00213               &lt;&lt; <span class="stringliteral">" objects"</span> &lt;&lt; endl;
00214       <span class="comment">// Will delete everything</span>
00215       <a class="code" href="classMC2Allocator.html#a2">initiate</a>(0);
00216       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"~MC2Allocator() leave"</span>);
00217    };
00218 
<a name="l00219"></a><a class="code" href="classMC2Allocator.html#a2">00219</a>    <span class="keywordtype">void</span> <a class="code" href="classMC2Allocator.html#a2">initiate</a>(<span class="keywordtype">int</span> n) {
00220       <span class="keyword">delete</span> [] m_block;
00221       <span class="keywordflow">if</span> (n &gt; 0)
00222          m_block = <span class="keyword">new</span> T[n];
00223       <span class="keywordflow">else</span>
00224          m_block = NULL;
00225 
00226       <span class="comment">// Initiate the members</span>
00227       m_blockAllocated = n;
00228       m_curBlockIndex = 0;
00229 
00230       <span class="comment">// Delete all objects in m_singleAllocated</span>
00231       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> slist&lt;T*&gt;<a class="code" href="structSTLUtility_1_1DualForwardIterator.html">::iterator</a> it = m_singleAllocated.begin();
00232             it != m_singleAllocated.end(); ++it) {
00233          <span class="keyword">delete</span> *it;
00234       }
00235 
00236       m_singleAllocated.clear();
00237    }
00238 
<a name="l00239"></a><a class="code" href="classMC2Allocator.html#a3">00239</a>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMC2Allocator.html#a3">reallocate</a>(<span class="keywordtype">int</span> n) {
00240       <span class="keyword">delete</span> [] m_block;
00241       <span class="keywordflow">if</span> (n &gt; 0)
00242          m_block = <span class="keyword">new</span> T[n];
00243       <span class="keywordflow">else</span>
00244          m_block = NULL;
00245 
00246       <span class="comment">// Initiate the members</span>
00247       m_blockAllocated = n;
00248       m_curBlockIndex = 0;
00249 
00250       <a class="code" href="namespaceSTLUtility.html#a3">STLUtility::deleteValues</a>( m_singleAllocated );
00251    }
00252 
<a name="l00253"></a><a class="code" href="classMC2Allocator.html#a4">00253</a>    <span class="keyword">virtual</span> <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2Allocator.html#a4">getBlockSize</a>()<span class="keyword"> const </span>{
00254       <span class="keywordflow">return</span> m_blockAllocated;
00255    }
00256 
<a name="l00257"></a><a class="code" href="classMC2Allocator.html#a5">00257</a>    <span class="keyword">virtual</span> <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2Allocator.html#a5">getTotalNbrElements</a>()<span class="keyword"> const </span>{
00258       <span class="keywordflow">return</span> m_curBlockIndex + m_singleAllocated.size();
00259    }
00260 
<a name="l00265"></a><a class="code" href="classMC2Allocator.html#a6">00265</a>    T* <a class="code" href="classMC2Allocator.html#a6">getNextObject</a>() {
00266       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"   MC2Allocator()::getNextObject() enter"</span>);
00267       T* retVal = NULL;
00268 
00269       <span class="keywordflow">if</span> (m_curBlockIndex &lt; m_blockAllocated) {
00270          <span class="comment">// OK, return pointer to object number m_curBlockIndex in m_block</span>
00271          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Allocator returned pointer to object"</span> &lt;&lt; endl;
00272          retVal = &amp;(m_block[m_curBlockIndex]);
00273          ++m_curBlockIndex;
00274       } <span class="keywordflow">else</span> {
00275          <span class="comment">// m_block is full, allocate new, put into m_singleAllocated </span>
00276          <span class="comment">// and return</span>
00277          retVal = <span class="keyword">new</span> T();
00278          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Allocator returned new object"</span> &lt;&lt; endl;
00279          m_singleAllocated.push_front(retVal);
00280       }
00281          
00282       <a class="code" href="MC2Logging_8h.html#a1">MINFO</a>(<span class="stringliteral">"   MC2Allocator()::getNextObject() leave"</span>);
00283       <span class="comment">// Return retVal</span>
00284       <span class="keywordflow">return</span> retVal;
00285    };
00286 
<a name="l00301"></a><a class="code" href="classMC2Allocator.html#a7">00301</a>    <span class="keywordtype">bool</span> <a class="code" href="classMC2Allocator.html#a7">handOverObject</a>(T* t) {
00302       <span class="comment">// Compare pointers to find out if t is in m_block</span>
00303       <span class="keywordflow">if</span> ( (t &gt;= m_block) &amp;&amp; 
00304            (t &lt; (m_block+m_curBlockIndex*<span class="keyword">sizeof</span>(T))) ) {
00305          <span class="comment">// OK, t is inside m_block</span>
00306          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"Found object in block in allocator"</span> &lt;&lt; endl;
00307          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00308       }
00309       <span class="comment">// Check all elements in m_singleAllocated</span>
00310       <span class="keyword">typename</span> slist&lt;T *&gt;<a class="code" href="structSTLUtility_1_1DualForwardIterator.html">::const_iterator</a> it = m_singleAllocated.begin();
00311       <span class="keywordflow">while</span> ( (it != m_singleAllocated.end()) &amp;&amp; (*it != t)) {
00312          ++it;
00313       }
00314 
00315       <span class="comment">// Add to m_singleAllocated if not found</span>
00316       <span class="keywordflow">if</span> (it == m_singleAllocated.end()) {
00317          m_singleAllocated.push_front(t);
00318          <a class="code" href="MC2Logging_8h.html#a3">mc2dbg1</a> &lt;&lt; <span class="stringliteral">"Found object that was not in allocator"</span> &lt;&lt; endl;
00319          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00320       }
00321       <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"Found object in list in allocator"</span> &lt;&lt; endl;
00322       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00323    };
00324 
00325    
<a name="l00326"></a><a class="code" href="classMC2Allocator.html#a8">00326</a>    <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">iterator</a> <a class="code" href="classMC2Allocator.html#a8">begin</a>() {
00327       <span class="keywordflow">return</span> <a class="code" href="classMC2Allocator.html#w0">iterator</a>( m_block, 
00328                        m_block + m_blockAllocated,
00329                        m_singleAllocated.begin() );
00330    }
00331 
<a name="l00332"></a><a class="code" href="classMC2Allocator.html#a9">00332</a>    <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">iterator</a> <a class="code" href="classMC2Allocator.html#a9">end</a>() {
00333       <span class="keywordflow">return</span> <a class="code" href="classMC2Allocator.html#w0">iterator</a>( m_block + m_blockAllocated, 
00334                        m_block + m_blockAllocated,
00335                        m_singleAllocated.end() );
00336    }
00337 
<a name="l00338"></a><a class="code" href="classMC2Allocator.html#a10">00338</a>    <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">const_iterator</a> <a class="code" href="classMC2Allocator.html#a8">begin</a>()<span class="keyword"> const </span>{
00339       <span class="keywordflow">return</span> <a class="code" href="classMC2Allocator.html#w1">const_iterator</a>( m_block, m_block + m_blockAllocated,
00340                              m_singleAllocated.begin() );
00341    }
<a name="l00342"></a><a class="code" href="classMC2Allocator.html#a11">00342</a>    <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">const_iterator</a> <a class="code" href="classMC2Allocator.html#a9">end</a>()<span class="keyword"> const </span>{
00343       <span class="keywordflow">return</span> <a class="code" href="classMC2Allocator.html#w1">const_iterator</a>( m_block + m_blockAllocated, 
00344                              m_block + m_blockAllocated,
00345                              m_singleAllocated.end() );
00346    }
<a name="l00349"></a><a class="code" href="classMC2Allocator.html#a12">00349</a>    <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2Allocator.html#a12">getPosition</a>( <span class="keyword">const</span> T* p )<span class="keyword"> const </span>{
00350       <span class="keywordflow">if</span> ( ! m_singleAllocated.empty() ) {
00351          <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">const_iterator</a> it = <a class="code" href="classMC2Allocator.html#a8">begin</a>();
00352          <a class="code" href="structSTLUtility_1_1DualForwardIterator.html">const_iterator</a> it_end = <a class="code" href="classMC2Allocator.html#a9">end</a>();
00353          <span class="keywordflow">for</span> (<a class="code" href="Types_8h.html#a21">uint32</a> distance = 0; it != it_end; ++it, ++distance ) {
00354             <span class="keywordflow">if</span> ( p == &amp;(*it) )
00355                <span class="keywordflow">return</span> distance;
00356          }
00357       } 
00358 
00359       <a class="code" href="config_8h.html#a29">MC2_ASSERT</a>( p &gt;= m_block &amp;&amp; p &lt; m_block + m_blockAllocated );
00360 
00361       <span class="keywordflow">return</span> p - m_block;
00362    }
00363 <span class="keyword">protected</span>:
<a name="l00364"></a><a class="code" href="classMC2Allocator.html#b0">00364</a>    <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="classMC2Allocator.html#b0">getSingleElementsSize</a>()<span class="keyword"> const </span>{
00365       <span class="keywordflow">return</span> m_singleAllocated.size();
00366    }
00367 <span class="keyword">private</span>:
<a name="l00371"></a><a class="code" href="classMC2Allocator.html#r0">00371</a>    T* m_block;
00372 
<a name="l00376"></a><a class="code" href="classMC2Allocator.html#r1">00376</a>    <span class="keywordtype">int</span> m_blockAllocated;
00377 
<a name="l00381"></a><a class="code" href="classMC2Allocator.html#r2">00381</a>    <span class="keywordtype">int</span> m_curBlockIndex;
00382       
<a name="l00387"></a><a class="code" href="classMC2Allocator.html#r3">00387</a>    slist&lt;T *&gt; m_singleAllocated;
00388 };
00389 
00390 <span class="preprocessor">#endif</span>
00391 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:45 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
