<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: BucketHeap.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Server</a>&nbsp;/&nbsp;<a class="el" href="dir_000010.html">Modules</a>&nbsp;/&nbsp;<a class="el" href="dir_000022.html">RouteModule</a>&nbsp;/&nbsp;<a class="el" href="dir_000023.html">include</a></div>
<h1>BucketHeap.h</h1><a href="BucketHeap_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (c) 1999 - 2010, Vodafone Group Services Ltd</span>
00003 <span class="comment">All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
00008 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
00009 <span class="comment">    * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
00010 <span class="comment"></span>
00011 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#ifndef BUCKETHEAP_H</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define BUCKETHEAP_H</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="config_8h.html">config.h</a>"</span>
00017 
00018 <span class="preprocessor">#if defined (__GNUC__) &amp;&amp; __GNUC__ &gt; 2</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ext/slist&gt;</span>
00020 <span class="keyword">using</span> <span class="keyword">namespace </span>__gnu_cxx;
00021 <span class="preprocessor">#else</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;slist&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include&lt;deque&gt;</span>
00025 <span class="preprocessor">#include&lt;list&gt;</span>
00026 <span class="preprocessor">#include "<a class="code" href="RedBlackTree_8h.html">RedBlackTree.h</a>"</span>
00027 
00028 <span class="preprocessor">#include "<a class="code" href="RoutingNode_8h.html">RoutingNode.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="OverflowNode_8h.html">OverflowNode.h</a>"</span>
00030 
00031 <span class="keyword">class </span><a class="code" href="classRoutingMap.html">RoutingMap</a>;
00032 
00033 <span class="comment">// If UNORDERED_BUCKET_HEAP is defined, only the buckets containing a</span>
00034 <span class="comment">// destination will be dequeued in order. I don't know how much faster</span>
00035 <span class="comment">// the program will run because of that.</span>
00036 
<a name="l00037"></a><a class="code" href="BucketHeap_8h.html#a0">00037</a> <span class="preprocessor">#define UNORDERED_BUCKET_HEAP</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#undef OLD_BUCKET_HEAP</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#ifndef OLD_BUCKET_HEAP</span>
00041 <span class="preprocessor"></span>
00042 <span class="comment">// Choose buckettype here</span>
00043 <span class="comment">//#define Bucket SlistBucket</span>
00044 <span class="comment">//#define Bucket DequeBucket</span>
<a name="l00045"></a><a class="code" href="BucketHeap_8h.html#a1">00045</a> <span class="preprocessor">#define Bucket ArrayBucket</span>
00046 <span class="preprocessor"></span>
00047 <span class="comment">//---------- SlistBucket -----------------</span>
00048 
00049 <span class="preprocessor">#if ( Bucket == SlistBucket )</span>
00050 <span class="preprocessor"></span>
<a name="l00056"></a><a class="code" href="classSlistBucket.html">00056</a> <span class="keyword">class </span><a class="code" href="classSlistBucket.html">SlistBucket</a> {
00057 <span class="keyword">public</span>:
00058 
00062    <span class="keyword">inline</span> <a class="code" href="classSlistBucket.html">SlistBucket</a>(<a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap, <span class="keywordtype">int</span> size);
00063    
00067    <span class="keyword">inline</span> <span class="keywordtype">void</span> enqueue(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node);
00068 
00072    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeue();
00073 
00077    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeueUnordered();
00078 
00082    <span class="keyword">inline</span> <span class="keywordtype">bool</span> isEmpty() <span class="keyword">const</span>;
00083 
00087    <span class="keyword">inline</span> <span class="keywordtype">void</span> reset();
00088 
00089 <span class="keyword">private</span>:
00090 
<a name="l00094"></a><a class="code" href="classSlistBucket.html#r0">00094</a>    <a class="code" href="classRoutingMap.html">RoutingMap</a>* m_map;
00095    
00099    <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeueCheapest();
00100 
<a name="l00104"></a><a class="code" href="classSlistBucket.html#r1">00104</a>    <span class="keywordtype">int</span> m_nbrDestsInBucket;
00105    
<a name="l00109"></a><a class="code" href="classSlistBucket.html#r2">00109</a>    slist&lt;RoutingNode*&gt; m_contents;
00110    
00111 };
00112 
00113 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00114"></a><a class="code" href="classSlistBucket.html#a5">00114</a> <a class="code" href="classSlistBucket.html#a5">SlistBucket::reset</a>()
00115 {
00116    <a class="code" href="classSlistBucket.html#r2">m_contents</a>.clear();
00117    <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> = 0;
00118 }
00119 
00120 <span class="keyword">inline</span>
<a name="l00121"></a><a class="code" href="classSlistBucket.html#a0">00121</a> <a class="code" href="classSlistBucket.html#a0">SlistBucket::SlistBucket</a>(<a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap, <span class="keywordtype">int</span> size)
00122 {
00123    <a class="code" href="classSlistBucket.html#r0">m_map</a> = theMap;
00124    <a class="code" href="classSlistBucket.html#a5">reset</a>();
00125 }
00126 
00127 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00128"></a><a class="code" href="classSlistBucket.html#a1">00128</a> <a class="code" href="classSlistBucket.html#a1">SlistBucket::enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node)
00129 {
00130    <a class="code" href="classSlistBucket.html#r2">m_contents</a>.push_front(node);
00131    <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> += ( node-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(<a class="code" href="classSlistBucket.html#r0">m_map</a>) != 0 );
00132 }
00133 
00134 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00135"></a><a class="code" href="classSlistBucket.html#a4">00135</a> <a class="code" href="classSlistBucket.html#a4">SlistBucket::isEmpty</a>()<span class="keyword"> const</span>
00136 <span class="keyword"></span>{
00137    <span class="keywordflow">return</span> <a class="code" href="classSlistBucket.html#r2">m_contents</a>.empty();
00138 }
00139 
00140 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00141"></a><a class="code" href="classSlistBucket.html#d0">00141</a> <a class="code" href="classSlistBucket.html#d0">SlistBucket::dequeueCheapest</a>()
00142 {
00143    <a class="code" href="Types_8h.html#a21">uint32</a> cheapestSoFar = MAX_UINT32;
00144    slist&lt;RoutingNode*&gt;::iterator cheapestNode = <a class="code" href="classSlistBucket.html#r2">m_contents</a>.begin();
00145    <span class="keywordflow">for</span>(slist&lt;RoutingNode*&gt;::iterator it = <a class="code" href="classSlistBucket.html#r2">m_contents</a>.begin();
00146        it != <a class="code" href="classSlistBucket.html#r2">m_contents</a>.end();
00147        ++it ) {
00148       <span class="keywordflow">if</span> ( (*it)-&gt;getEstCost(<a class="code" href="classSlistBucket.html#r0">m_map</a>) &lt; cheapestSoFar ) {
00149          cheapestNode = it;
00150          cheapestSoFar = (*it)-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(<a class="code" href="classSlistBucket.html#r0">m_map</a>);
00151       }
00152    }
00153    <a class="code" href="classRoutingNode.html">RoutingNode</a>* retVal = *cheapestNode;
00154    <a class="code" href="classSlistBucket.html#r2">m_contents</a>.erase(cheapestNode); <span class="comment">// XXX: Slow?</span>
00155    <span class="keywordflow">return</span> retVal;
00156 }
00157 
00158 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00159"></a><a class="code" href="classSlistBucket.html#a2">00159</a> <a class="code" href="classSlistBucket.html#a2">SlistBucket::dequeue</a>()
00160 {
00161    <a class="code" href="classRoutingNode.html">RoutingNode</a>* retVal;
00162    <span class="keywordflow">if</span> ( m_nbrDestsInBucket ) {
00163       <span class="comment">// FIXME: Extra queue for destinations</span>
00164       retVal = <a class="code" href="classSlistBucket.html#d0">dequeueCheapest</a>();
00165    } <span class="keywordflow">else</span> {
00166       retVal = <a class="code" href="classSlistBucket.html#r2">m_contents</a>.front();
00167       <a class="code" href="classSlistBucket.html#r2">m_contents</a>.pop_front();
00168    }
00169    <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> -= ( retVal-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(<a class="code" href="classSlistBucket.html#r0">m_map</a>) != 0 );
00170    <span class="keywordflow">return</span> retVal;
00171 }
00172 
00173 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00174"></a><a class="code" href="classSlistBucket.html#a3">00174</a> <a class="code" href="classSlistBucket.html#a3">SlistBucket::dequeueUnordered</a>()
00175 {
00176    <span class="keywordflow">if</span> ( !<a class="code" href="classSlistBucket.html#r2">m_contents</a>.empty() ) {
00177       <span class="comment">// Implement correctly</span>
00178       <a class="code" href="classRoutingNode.html">RoutingNode</a>* retVal = <a class="code" href="classSlistBucket.html#r2">m_contents</a>.front();
00179       <a class="code" href="classSlistBucket.html#r2">m_contents</a>.pop_front();
00180       <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> -= ( retVal-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(<a class="code" href="classSlistBucket.html#r0">m_map</a>) != 0 );
00181       <span class="keywordflow">return</span> retVal;
00182    } <span class="keywordflow">else</span> {
00183       <span class="keywordflow">if</span> ( <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> != 0 ) {
00184          <a class="code" href="MC2Logging_8h.html#a0">mc2log</a> &lt;&lt; <a class="code" href="MC2Logging_8h.html#a16">error</a> &lt;&lt; <span class="stringliteral">"[BH] - bucket is empty but nbrDests is "</span>
00185                 &lt;&lt; <a class="code" href="classSlistBucket.html#r1">m_nbrDestsInBucket</a> &lt;&lt; endl;
00186       }
00187       <span class="keywordflow">return</span> NULL;
00188    }  
00189 }
00190 
00191 <span class="preprocessor">#endif // Bucket == SlistBucket</span>
00192 <span class="preprocessor"></span>
00193 <span class="preprocessor">#if ( Bucket == DequeBucket ) </span>
00194 <span class="preprocessor"></span>
00195 <span class="comment">// -------------- DequeBucket</span>
00196 
<a name="l00203"></a><a class="code" href="classDequeBucket.html">00203</a> <span class="keyword">class </span><a class="code" href="classDequeBucket.html">DequeBucket</a> : <span class="keyword">private</span> list&lt;RoutingNode*&gt; {
00204 <span class="keyword">public</span>:
00205 
00209    <span class="keyword">inline</span> <a class="code" href="classDequeBucket.html#a0">DequeBucket</a>(<span class="keyword">const</span> <a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap, <span class="keywordtype">int</span> size);
00210    
00214    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classDequeBucket.html#a1">enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node);
00215 
00219    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* <a class="code" href="classDequeBucket.html#a2">dequeue</a>();
00220 
00224    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* <a class="code" href="classDequeBucket.html#a3">dequeueUnordered</a>();
00225 
00229    <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classDequeBucket.html#a4">isEmpty</a>() <span class="keyword">const</span>;
00230 
00234    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classDequeBucket.html#a5">reset</a>();
00235    
00236 <span class="keyword">private</span>:
00237 
<a name="l00241"></a><a class="code" href="classDequeBucket.html#r0">00241</a>    <span class="keyword">const</span> <a class="code" href="classRoutingMap.html">RoutingMap</a>* m_map;
00242    
00243 };
00244 
00245 <span class="keyword">inline</span>
<a name="l00246"></a><a class="code" href="classDequeBucket.html#a0">00246</a> <a class="code" href="classDequeBucket.html#a0">DequeBucket::DequeBucket</a>(<span class="keyword">const</span> <a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap,
00247                          <span class="keywordtype">int</span> size) : list&lt;<a class="code" href="classRoutingNode.html">RoutingNode</a>*&gt;()
00248 {
00249    <a class="code" href="classDequeBucket.html#r0">m_map</a> = theMap;
00250 }
00251 
00252 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00253"></a><a class="code" href="classDequeBucket.html#a1">00253</a> <a class="code" href="classDequeBucket.html#a1">DequeBucket::enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node)
00254 {
00255    <span class="comment">// Put the destinations in the front so that they will</span>
00256    <span class="comment">// be dequeued last.</span>
00257    <span class="keywordflow">if</span> ( <a class="code" href="config_8h.html#a23">MC2_UNLIKELY</a>(node-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(<a class="code" href="classDequeBucket.html#r0">m_map</a>)) ) {
00258       push_front(node);
00259    } <span class="keywordflow">else</span> {
00260       push_back(node);
00261    }
00262 }
00263 
00264 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00265"></a><a class="code" href="classDequeBucket.html#a2">00265</a> <a class="code" href="classDequeBucket.html#a2">DequeBucket::dequeue</a>()
00266 {
00267    <a class="code" href="classRoutingNode.html">RoutingNode</a>* retVal = back();
00268    pop_back();
00269    <span class="keywordflow">return</span> retVal;
00270 }
00271 
00272 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00273"></a><a class="code" href="classDequeBucket.html#a4">00273</a> <a class="code" href="classDequeBucket.html#a4">DequeBucket::isEmpty</a>()<span class="keyword"> const</span>
00274 <span class="keyword"></span>{
00275    <span class="keywordflow">return</span> empty();
00276 }
00277 
00278 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00279"></a><a class="code" href="classDequeBucket.html#a3">00279</a> <a class="code" href="classDequeBucket.html#a3">DequeBucket::dequeueUnordered</a>()
00280 {
00281    <span class="keywordflow">if</span> ( <a class="code" href="classDequeBucket.html#a4">isEmpty</a>() ) {
00282       <span class="keywordflow">return</span> NULL;
00283    } <span class="keywordflow">else</span> {
00284       <span class="keywordflow">return</span> <a class="code" href="classDequeBucket.html#a2">dequeue</a>();
00285    }
00286 }
00287 
00288 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00289"></a><a class="code" href="classDequeBucket.html#a5">00289</a> <a class="code" href="classDequeBucket.html#a5">DequeBucket::reset</a>()
00290 {
00291    clear();
00292 }
00293 
00294 <span class="preprocessor">#endif // Bucket == DequeBucket</span>
00295 <span class="preprocessor"></span>
00296 <span class="preprocessor">#if ( Bucket == ArrayBucket ) </span>
00297 <span class="preprocessor"></span>
00298 <span class="comment">// -------------- ArrayBucket</span>
00299 
<a name="l00304"></a><a class="code" href="classArrayBucket.html">00304</a> <span class="keyword">class </span><a class="code" href="classArrayBucket.html">ArrayBucket</a> {
00305 <span class="keyword">public</span>:
00306 
00310    <span class="keyword">inline</span> <a class="code" href="classArrayBucket.html">ArrayBucket</a>(<a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap, <span class="keywordtype">int</span> size);
00311 
00315    <span class="keyword">inline</span> ~<a class="code" href="classArrayBucket.html">ArrayBucket</a>();
00316    
00320    <span class="keyword">inline</span> <span class="keywordtype">void</span> enqueue(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node);
00321 
00325    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeue();
00326 
00330    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeueUnordered();
00331 
00335    <span class="keyword">inline</span> <span class="keywordtype">bool</span> isEmpty() <span class="keyword">const</span>;
00336 
00340    <span class="keyword">inline</span> <span class="keywordtype">void</span> reset();
00341    
00342 <span class="keyword">private</span>:
00343 
<a name="l00347"></a><a class="code" href="classArrayBucket.html#r0">00347</a>    <a class="code" href="classRoutingNode.html">RoutingNode</a>** m_array;
00348 
<a name="l00352"></a><a class="code" href="classArrayBucket.html#r1">00352</a>    <span class="keyword">const</span> <span class="keywordtype">int</span> m_arraySize;
00353 
<a name="l00357"></a><a class="code" href="classArrayBucket.html#r2">00357</a>    <span class="keywordtype">int</span> m_nbrUsedInArray;
00358    
<a name="l00362"></a><a class="code" href="classArrayBucket.html#r3">00362</a>    <a class="code" href="classRedBlackTree.html">RedBlackTree</a> m_dests;
00363 
<a name="l00367"></a><a class="code" href="classArrayBucket.html#r4">00367</a>    list&lt;RoutingNode*&gt; m_overflow;
00368 
<a name="l00372"></a><a class="code" href="classArrayBucket.html#r5">00372</a>    <a class="code" href="classRoutingMap.html">RoutingMap</a>* m_map;
00373    
00374 };
00375 
00376 <span class="keywordtype">void</span>
<a name="l00377"></a><a class="code" href="classArrayBucket.html#a6">00377</a> <a class="code" href="classArrayBucket.html#a6">ArrayBucket::reset</a>()
00378 {
00379    <a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a> = 0;
00380    <a class="code" href="classArrayBucket.html#r3">m_dests</a>.<a class="code" href="classRedBlackTree.html#a1">reset</a>();
00381    <a class="code" href="classArrayBucket.html#r4">m_overflow</a>.clear();
00382 }
00383 
00384 <span class="keyword">inline</span>
<a name="l00385"></a><a class="code" href="classArrayBucket.html#a0">00385</a> <a class="code" href="classArrayBucket.html#a0">ArrayBucket::ArrayBucket</a>(<a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap, <span class="keywordtype">int</span> size)
00386       : m_arraySize(size),
00387         m_dests(theMap)
00388 {
00389    <a class="code" href="classArrayBucket.html#r5">m_map</a> = theMap;
00390    <a class="code" href="classArrayBucket.html#r0">m_array</a> = <span class="keyword">new</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*[size];
00391    <a class="code" href="classArrayBucket.html#a6">reset</a>();
00392 }
00393 
00394 <span class="keyword">inline</span>
<a name="l00395"></a><a class="code" href="classArrayBucket.html#a1">00395</a> <a class="code" href="classArrayBucket.html#a1">ArrayBucket::~ArrayBucket</a>()
00396 {
00397    <span class="keyword">delete</span> [] m_array;
00398 }
00399 
00400 <span class="keywordtype">void</span>
<a name="l00401"></a><a class="code" href="classArrayBucket.html#a2">00401</a> <a class="code" href="classArrayBucket.html#a2">ArrayBucket::enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node)
00402 {
00403    <span class="keywordflow">if</span> ( node-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(<a class="code" href="classArrayBucket.html#r5">m_map</a>) == false ) {
00404       <span class="keywordflow">if</span> ( <a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a> &lt; m_arraySize ) {
00405          <a class="code" href="classArrayBucket.html#r0">m_array</a>[<a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a>++] = node;
00406       } <span class="keywordflow">else</span> {
00407          <a class="code" href="classArrayBucket.html#r4">m_overflow</a>.push_front(node);
00408          ++m_nbrUsedInArray;
00409       }
00410    } <span class="keywordflow">else</span> {
00411       <a class="code" href="classArrayBucket.html#r3">m_dests</a>.<a class="code" href="classRedBlackTree.html#a5">enqueue</a>(node);
00412    }
00413 }
00414 
00415 <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00416"></a><a class="code" href="classArrayBucket.html#a3">00416</a> <a class="code" href="classArrayBucket.html#a3">ArrayBucket::dequeue</a>()
00417 {
00418    <span class="keywordflow">if</span> ( <a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a> != 0 ) {
00419       <span class="keywordflow">if</span> ( <a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a> &lt;= m_arraySize  ) {
00420          <span class="keywordflow">return</span> <a class="code" href="classArrayBucket.html#r0">m_array</a>[--m_nbrUsedInArray];
00421       } <span class="keywordflow">else</span> {
00422          <a class="code" href="classRoutingNode.html">RoutingNode</a>* node = <a class="code" href="classArrayBucket.html#r4">m_overflow</a>.back();
00423          <a class="code" href="classArrayBucket.html#r4">m_overflow</a>.pop_back();
00424          --m_nbrUsedInArray;
00425          <span class="keywordflow">return</span> node;
00426       }
00427    } <span class="keywordflow">else</span> {
00428       <span class="comment">// Only destinations left</span>
00429       <span class="keywordflow">return</span> <a class="code" href="classArrayBucket.html#r3">m_dests</a>.<a class="code" href="classRedBlackTree.html#a3">dequeue</a>();
00430    }          
00431 }
00432 
00433 <span class="keywordtype">bool</span>
<a name="l00434"></a><a class="code" href="classArrayBucket.html#a5">00434</a> <a class="code" href="classArrayBucket.html#a5">ArrayBucket::isEmpty</a>()<span class="keyword"> const</span>
00435 <span class="keyword"></span>{
00436    <span class="keywordflow">return</span> <a class="code" href="classArrayBucket.html#r2">m_nbrUsedInArray</a> == 0 &amp;&amp; <a class="code" href="classArrayBucket.html#r3">m_dests</a>.<a class="code" href="classRedBlackTree.html#a2">isEmpty</a>();
00437 }
00438 
00439 <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00440"></a><a class="code" href="classArrayBucket.html#a4">00440</a> <a class="code" href="classArrayBucket.html#a4">ArrayBucket::dequeueUnordered</a>()
00441 {
00442    <span class="keywordflow">if</span> ( !<a class="code" href="classArrayBucket.html#a5">isEmpty</a>() ) {
00443       <span class="keywordflow">return</span> <a class="code" href="classArrayBucket.html#a3">dequeue</a>();
00444    } <span class="keywordflow">else</span> {
00445       <span class="keywordflow">return</span> NULL;
00446    }
00447 }
00448 
00449 <span class="preprocessor">#endif // Bucket == ArrayBucket</span>
00450 <span class="preprocessor"></span>
00451 <span class="preprocessor">#endif</span>
00452 <span class="preprocessor"></span>
00453 
<a name="l00459"></a><a class="code" href="classBucketHeap.html">00459</a> <span class="keyword">class </span><a class="code" href="classBucketHeap.html">BucketHeap</a>
00460 {
00461 <span class="keyword">public</span>:
00462    
00466    <a class="code" href="classBucketHeap.html">BucketHeap</a>(<a class="code" href="classRoutingMap.html">RoutingMap</a>* theMap);
00467 
00471    ~<a class="code" href="classBucketHeap.html">BucketHeap</a>();
00472 
00479    <span class="keyword">inline</span> <span class="keywordtype">void</span> enqueue(<a class="code" href="classRoutingNode.html">RoutingNode</a>* routingNode);
00480    
00487    <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeue();
00488 
00489 <span class="preprocessor">#ifdef OLD_BUCKET_HEAP</span>
00490 <span class="preprocessor"></span>   <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>* dequeue2();
00491 <span class="preprocessor">#endif</span>
00492 <span class="preprocessor"></span>   
00498    <span class="keyword">inline</span> <span class="keywordtype">bool</span> isEmpty();
00499    
00506    <span class="keywordtype">void</span> reset();
00507    
00513    <span class="keyword">inline</span> <span class="keywordtype">void</span> updateStartIndex (<a class="code" href="Types_8h.html#a21">uint32</a> cost);
00514 
00515 <span class="preprocessor">#ifdef OLD_BUCKET_HEAP</span>
00516 <span class="preprocessor"></span>
00520    <span class="keywordtype">void</span> dump();
00521    
00529    <span class="keywordtype">bool</span> checkHeapConsistency();
00530 <span class="preprocessor">#endif</span>
00531 <span class="preprocessor"></span>   
00532   <span class="keyword">private</span>:
00533    
00538    <span class="keyword">inline</span> <span class="keywordtype">void</span> flushHeap();
00539    
00540 <span class="preprocessor">#ifndef OLD_BUCKET_HEAP</span>
00541 <span class="preprocessor"></span>   <span class="keyword">inline</span> <a class="code" href="Types_8h.html#a21">uint32</a> calcRowIndex(<a class="code" href="Types_8h.html#a21">uint32</a> cost);
00542 <span class="preprocessor">#endif</span>
00543 <span class="preprocessor"></span>   
00547    <span class="keywordtype">void</span> tryToEmptyLargeCostsBucket();
00548 
00549 <span class="preprocessor">#ifdef OLD_BUCKET_HEAP</span>
00550 <span class="preprocessor"></span>
00557    <span class="keywordtype">void</span> overflowEnqueue(<a class="code" href="classRoutingNode.html">RoutingNode</a>* routingNode, <a class="code" href="Types_8h.html#a22">int32</a> rowIndex);
00558    
00566    <a class="code" href="classRoutingNode.html">RoutingNode</a>* overflowDequeue();
00567 
00576    <span class="keywordtype">void</span> emptyLargeCostsOverflow(<a class="code" href="Types_8h.html#a21">uint32</a> costsHandled);
00577 <span class="preprocessor">#endif</span>
00578 <span class="preprocessor"></span>   
00580 <span class="comment">// Constant variables used by the BucketHeap</span>
00582 <span class="comment"></span>
<a name="l00586"></a><a class="code" href="classBucketHeap.html#v0">00586</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> ROWS = 8000;
00587 
<a name="l00591"></a><a class="code" href="classBucketHeap.html#v1">00591</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> COLUMNS = 256;
00592 
<a name="l00596"></a><a class="code" href="classBucketHeap.html#v2">00596</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> LARGE_COSTS_BUCKET_SIZE = COLUMNS * COLUMNS;
00597 
<a name="l00602"></a><a class="code" href="classBucketHeap.html#v3">00602</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> BUCKET_COST_DIFFERENCE_EXP = 10;
00603 
<a name="l00607"></a><a class="code" href="classBucketHeap.html#v4">00607</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> BUCKET_COST_DIFFERENCE = 1024;
00608    
<a name="l00612"></a><a class="code" href="classBucketHeap.html#v5">00612</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> RANGE_OF_COSTS_IN_HEAP =
00613       (ROWS * BUCKET_COST_DIFFERENCE - 1);
00614 
00616 <span class="comment">// Member variables</span>
00618 <span class="comment"></span><span class="preprocessor">#ifdef OLD_BUCKET_HEAP</span>
00619 <span class="preprocessor"></span>
00622    <a class="code" href="classRoutingNode.html">RoutingNode</a>* m_matrix[ROWS][COLUMNS];
00623    
00627    <a class="code" href="classRoutingNode.html">RoutingNode</a>* m_largeCostsBucket[COLUMNS * COLUMNS];
00628 
00632    <a class="code" href="Types_8h.html#a21">uint32</a> m_nbrUsed[ROWS];
00633 
00639    <a class="code" href="Types_8h.html#a21">uint32</a> m_nbrDestinations[ROWS];
00640    
00644    <a class="code" href="classHead.html">Head</a>* m_overflowLists[ROWS];
00645    
00649    <a class="code" href="Types_8h.html#a21">uint32</a> m_nbrUsedInLargeCostsBucket;
00650 
00654    <a class="code" href="classHead.html">Head</a>* m_largeCostsOverflow;
00655    
00660    <span class="keywordtype">bool</span> m_overflowHasOccurred;
00661 <span class="preprocessor">#else </span>
00662 <span class="preprocessor"></span>
<a name="l00665"></a><a class="code" href="classBucketHeap.html#r0">00665</a>    <a class="code" href="BucketHeap_8h.html#a1">Bucket</a>* m_buckets[ROWS+1];
00666 <span class="preprocessor">#endif</span>
00667 <span class="preprocessor"></span>
<a name="l00671"></a><a class="code" href="classBucketHeap.html#r1">00671</a>    <a class="code" href="Types_8h.html#a21">uint32</a> m_heapStartIndex;
00672    
<a name="l00676"></a><a class="code" href="classBucketHeap.html#r2">00676</a>    <a class="code" href="Types_8h.html#a21">uint32</a> m_leastExpectedCostInHeap;
00677 
<a name="l00681"></a><a class="code" href="classBucketHeap.html#r3">00681</a>    <a class="code" href="Types_8h.html#a21">uint32</a> m_totalNbrUsed;
00682 
<a name="l00686"></a><a class="code" href="classBucketHeap.html#r4">00686</a>    <a class="code" href="classRoutingMap.html">RoutingMap</a>* m_map;
00687 
00688 }; <span class="comment">// BucketHeap</span>
00689 
<a name="l00690"></a><a class="code" href="classBucketHeap.html#a4">00690</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classBucketHeap.html#a4">BucketHeap::isEmpty</a>()
00691 {
00692    <span class="keywordflow">return</span> <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a> == 0;
00693 }
00694 
00696 <span class="comment">// Inline functions for new BucketHeap</span>
00698 <span class="comment"></span><span class="preprocessor">#ifndef OLD_BUCKET_HEAP</span>
00699 <span class="preprocessor"></span><span class="keyword">inline</span>
00700 <span class="keywordtype">void</span>
<a name="l00701"></a><a class="code" href="classBucketHeap.html#a5">00701</a> <a class="code" href="classBucketHeap.html#a5">BucketHeap::reset</a>()
00702 {
00703    <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a>   = 0;
00704    <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a>              = 0;
00705    <a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a>            = 0;
00706    <span class="keywordflow">for</span>(<a class="code" href="Types_8h.html#a21">uint32</a> i=0; i &lt; <a class="code" href="classBucketHeap.html#v0">ROWS</a> + 1 ; ++i ) {
00707       <a class="code" href="classBucketHeap.html#r0">m_buckets</a>[i]-&gt;<a class="code" href="classArrayBucket.html#a6">reset</a>();
00708    }
00709 }
00710 
00711 <span class="keyword">inline</span> <a class="code" href="Types_8h.html#a21">uint32</a>
<a name="l00712"></a><a class="code" href="classBucketHeap.html#d1">00712</a> <a class="code" href="classBucketHeap.html#d1">BucketHeap::calcRowIndex</a>(uint32 cost)
00713 {
00714    <span class="keywordflow">if</span> ( cost &gt; ( <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> + RANGE_OF_COSTS_IN_HEAP) ) {
00715       <span class="keywordflow">return</span> ROWS; <span class="comment">// Largecosts bucket.</span>
00716    }
00717    <span class="keywordflow">if</span> ( cost &lt; m_leastExpectedCostInHeap ) {
00718       <span class="keywordflow">return</span> m_heapStartIndex;
00719    } <span class="keywordflow">else</span> {
00720       <a class="code" href="Types_8h.html#a21">uint32</a> rowIndex = ((cost - m_leastExpectedCostInHeap)
00721                          &gt;&gt; BUCKET_COST_DIFFERENCE_EXP) + m_heapStartIndex;
00722       <span class="keywordflow">if</span> (rowIndex &gt;= (int32) ROWS) {
00723          rowIndex -= ROWS;
00724       }
00725       <span class="keywordflow">return</span> rowIndex;
00726    }
00727 }
00728 
<a name="l00729"></a><a class="code" href="classBucketHeap.html#a2">00729</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classBucketHeap.html#a2">BucketHeap::enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* node)
00730 {
00731    <span class="keyword">const</span> <a class="code" href="Types_8h.html#a21">uint32</a> rowIdx = <a class="code" href="classBucketHeap.html#d1">calcRowIndex</a>(node-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(<a class="code" href="classBucketHeap.html#r4">m_map</a>));
00732    <span class="comment">// Largecosts bucket should be the last (at ROWS) </span>
00733    <a class="code" href="classBucketHeap.html#r0">m_buckets</a>[rowIdx]-&gt;<a class="code" href="classArrayBucket.html#a2">enqueue</a>(node);
00734    ++m_totalNbrUsed;
00735 }
00736 
00737 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00738"></a><a class="code" href="classBucketHeap.html#d0">00738</a> <a class="code" href="classBucketHeap.html#d0">BucketHeap::flushHeap</a>()
00739 {
00740    <span class="keywordflow">if</span> ( ! <a class="code" href="classBucketHeap.html#a4">isEmpty</a>() ) {
00741       <span class="keywordflow">while</span>( <a class="code" href="classBucketHeap.html#r0">m_buckets</a>[m_heapStartIndex]-&gt;<a class="code" href="classArrayBucket.html#a5">isEmpty</a>() ) {
00742          <span class="keywordflow">if</span> ( ++<a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> == ROWS ) {
00743             <a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> = 0;
00744             <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> += BUCKET_COST_DIFFERENCE;
00745             <span class="keywordflow">if</span> ( ! <a class="code" href="classBucketHeap.html#r0">m_buckets</a>[ROWS]-&gt;<a class="code" href="classArrayBucket.html#a5">isEmpty</a>() ) {
00746                <a class="code" href="classBucketHeap.html#d2">tryToEmptyLargeCostsBucket</a>();
00747             }
00748          } <span class="keywordflow">else</span> {
00749             <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> += BUCKET_COST_DIFFERENCE;
00750          }
00751       }
00752    }
00753 }
00754 
00755 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
<a name="l00756"></a><a class="code" href="classBucketHeap.html#a3">00756</a> <a class="code" href="classBucketHeap.html#a3">BucketHeap::dequeue</a>()
00757 {
00758    <a class="code" href="classBucketHeap.html#d0">flushHeap</a>();
00759    <a class="code" href="classRoutingNode.html">RoutingNode</a>* res = <a class="code" href="classBucketHeap.html#r0">m_buckets</a>[m_heapStartIndex]-&gt;<a class="code" href="classArrayBucket.html#a3">dequeue</a>();
00760    <span class="keywordflow">if</span> ( res ) {
00761       --m_totalNbrUsed;
00762    }
00763    <span class="keywordflow">return</span> res;
00764 }
00765 
00766 <span class="preprocessor">#endif</span>
00767 <span class="preprocessor"></span>
00768 <span class="comment">// Inline functions for old BucketHeap</span>
00770 <span class="comment"></span><span class="preprocessor">#ifdef OLD_BUCKET_HEAP</span>
00771 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classBucketHeap.html#a2">BucketHeap::enqueue</a>(<a class="code" href="classRoutingNode.html">RoutingNode</a>* routingNode)
00772 {
00773    <a class="code" href="Types_8h.html#a21">uint32</a> cost = routingNode-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(m_map);
00774 <span class="comment">//     if ( cost == MAX_UINT32 )</span>
00775 <span class="comment">//        mc2log &lt;&lt; warn &lt;&lt; "enqueueing node with cost MAX_UINT32" &lt;&lt; endl;</span>
00776    
00777    <a class="code" href="Types_8h.html#a22">int32</a> rowIndex;
00778    <span class="keywordflow">if</span> (cost &gt; (m_leastExpectedCostInHeap + RANGE_OF_COSTS_IN_HEAP)) {
00779       <span class="comment">// Too large cost, put it in largeCostsBucket</span>
00780       <span class="keywordflow">if</span> (m_nbrUsedInLargeCostsBucket &lt; LARGE_COSTS_BUCKET_SIZE) {
00781          m_largeCostsBucket[m_nbrUsedInLargeCostsBucket++] = routingNode;
00782       } <span class="keywordflow">else</span> {
00783          overflowEnqueue(routingNode, MAX_INT32);
00784       }
00785    } <span class="keywordflow">else</span> {
00786       <span class="keywordflow">if</span> (cost &lt; m_leastExpectedCostInHeap) {
00787          <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Too small cost in heap"</span> &lt;&lt; endl;
00788          rowIndex = m_heapStartIndex;
00789       } <span class="keywordflow">else</span> {
00790          rowIndex = ((cost - m_leastExpectedCostInHeap)
00791                      &gt;&gt; BUCKET_COST_DIFFERENCE_EXP) + m_heapStartIndex;
00792          <span class="keywordflow">if</span> (rowIndex &gt;= (int32) ROWS)
00793             rowIndex -= ROWS;
00794       }
00795       
00796       <span class="keywordflow">if</span> (m_nbrUsed[rowIndex] &lt; COLUMNS) {
00797          m_matrix[rowIndex][m_nbrUsed[rowIndex]++] = routingNode;
00798 <span class="preprocessor">#ifdef UNORDERED_BUCKET_HEAP</span>
00799 <span class="preprocessor"></span>         <span class="comment">// Check if the node is a destination and increase counter.</span>
00800 <span class="comment">//           if ( routingNode-&gt;isDest(m_map) )</span>
00801 <span class="comment">//              m_nbrDestinations[rowIndex]++;</span>
00802          m_nbrDestinations[rowIndex] += (routingNode-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(m_map) == <span class="keyword">true</span>);
00803 <span class="preprocessor">#endif</span>
00804 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> {
00805          overflowEnqueue(routingNode, rowIndex);
00806       }
00807    }
00808    
00809    <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a>++;
00810    
00811 } <span class="comment">// enqueue</span>
00812 
00813 
00814 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classBucketHeap.html#d0">BucketHeap::flushHeap</a>()
00815 {
00816    <span class="keywordflow">if</span>( <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a> &gt; 0  ) {
00817       <span class="keywordflow">while</span> (m_nbrUsed[m_heapStartIndex] == 0) {
00818          <span class="keywordflow">if</span> (++<a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> == ROWS) {
00819             <a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> = 0;
00820             <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> += BUCKET_COST_DIFFERENCE;
00821             <span class="keywordflow">if</span> (m_nbrUsedInLargeCostsBucket &gt; 0)
00822                <a class="code" href="classBucketHeap.html#d2">tryToEmptyLargeCostsBucket</a>();
00823          }
00824          <span class="keywordflow">else</span>
00825             <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> += BUCKET_COST_DIFFERENCE;
00826       }
00827    } <span class="keywordflow">else</span> {
00828       <a class="code" href="config_8h.html#a13">MC2ERROR</a>(<span class="stringliteral">"BucketHeap::flushHeap with empty heap"</span>);
00829    }
00830 }
00831 
00832 
00833 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
00834 <a class="code" href="classBucketHeap.html#a3">BucketHeap::dequeue</a>()
00835 {
00836    <a class="code" href="classRoutingNode.html">RoutingNode</a>* minNode = NULL;
00837    <a class="code" href="Types_8h.html#a21">uint32</a> minCost = MAX_UINT32;
00838    
00839    <a class="code" href="classBucketHeap.html#d0">flushHeap</a>();
00840 
00841    <span class="keywordflow">if</span> ( !m_overflowLists[m_heapStartIndex]-&gt;empty() ){
00842       minNode = overflowDequeue();
00843    } <span class="keywordflow">else</span> {
00844       <a class="code" href="Types_8h.html#a21">uint32</a> minIndex = 0;
00845       <a class="code" href="Types_8h.html#a21">uint32</a> nbrElements = m_nbrUsed[m_heapStartIndex];
00846       <a class="code" href="classRoutingNode.html">RoutingNode</a>** minimumCostBucket = m_matrix[m_heapStartIndex];
00847 <span class="preprocessor">#ifdef UNORDERED_BUCKET_HEAP</span>
00848 <span class="preprocessor"></span>      <span class="comment">// Don't dequeue in order if the bucket doesn't contain a destination.</span>
00849       <span class="keyword">const</span> <span class="keywordtype">bool</span> checkOrder = m_nbrDestinations[m_heapStartIndex];
00850 <span class="preprocessor">#else</span>
00851 <span class="preprocessor"></span>      <span class="comment">// Always dequeue in order.</span>
00852       <span class="keyword">const</span> <span class="keywordtype">bool</span> checkOrder = <span class="keyword">true</span>; <span class="comment">// Should be optimized away, I hope.</span>
00853 <span class="preprocessor">#endif      </span>
00854 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( checkOrder ) {
00855          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nbrElements - 1; i &gt;= 0; --i) {      
00856             <a class="code" href="classRoutingNode.html">RoutingNode</a>* <span class="keyword">const</span> tempNode = minimumCostBucket[i];
00857             <span class="keywordflow">if</span> (tempNode-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(m_map) &lt;= minCost) {
00858                minCost  = tempNode-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(m_map);
00859                minNode  = tempNode;
00860                minIndex = i;
00861             }
00862          }
00863          minimumCostBucket[minIndex] = minimumCostBucket[nbrElements - 1];
00864 <span class="preprocessor">#ifdef UNORDERED_BUCKET_HEAP</span>
00865 <span class="preprocessor"></span>         m_nbrDestinations[m_heapStartIndex] -= ( minNode-&gt;<a class="code" href="classRoutingNode.html#a12">isDest</a>(m_map) == <span class="keyword">true</span>);
00866 <span class="comment">/*           if ( minNode-&gt;isDest(m_map) ) */</span>
00867 <span class="comment">/*              m_nbrDestinations[m_heapStartIndex]--; */</span>
00868 <span class="preprocessor">#endif</span>
00869 <span class="preprocessor"></span>      } <span class="keywordflow">else</span> {
00870 <span class="preprocessor">#ifdef UNORDERED_BUCKET_HEAP         </span>
00871 <span class="preprocessor"></span>         <span class="comment">// Dequeue the middle one. This is an experiment. Call it</span>
00872          <span class="comment">// heuristics.</span>
00873          <span class="comment">// Shouldn't be a destination, since we aren't checking order.</span>
00874          minIndex = nbrElements &gt;&gt; 1;
00875          minNode = minimumCostBucket[minIndex];
00876          minimumCostBucket[minIndex] = minimumCostBucket[nbrElements - 1];
00877 
00878 <span class="preprocessor">#endif</span>
00879 <span class="preprocessor"></span>      }      
00880       m_nbrUsed[m_heapStartIndex]--;
00881    }
00882    <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a>--;
00883    <span class="keywordflow">return</span> minNode;
00884 } <span class="comment">// dequeue</span>
00885 
00886 <span class="keyword">inline</span> <a class="code" href="classRoutingNode.html">RoutingNode</a>*
00887 BucketHeap::dequeue2()
00888 {
00889    <a class="code" href="MC2Logging_8h.html#a4">mc2dbg2</a> &lt;&lt; <span class="stringliteral">"BucketHeap::dequeue2"</span> &lt;&lt; endl;
00890    <a class="code" href="classRoutingNode.html">RoutingNode</a>* minNode = NULL;
00891    <a class="code" href="Types_8h.html#a21">uint32</a> minCost = MAX_UINT32;
00892    
00893    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"Before flushheap"</span> &lt;&lt; endl;
00894    <a class="code" href="classBucketHeap.html#d0">flushHeap</a>();
00895    <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"After flushheap"</span> &lt;&lt; endl;
00896 
00897    <span class="keywordflow">if</span> (m_overflowHasOccurred &amp;&amp; (!m_overflowLists[m_heapStartIndex]-&gt;empty()))
00898       minNode = overflowDequeue();
00899    <span class="keywordflow">else</span> {
00900       <a class="code" href="MC2Logging_8h.html#a5">mc2dbg4</a> &lt;&lt; <span class="stringliteral">"else"</span> &lt;&lt; endl;
00901 
00902       <a class="code" href="classRoutingNode.html">RoutingNode</a>* tempNode;
00903       <a class="code" href="Types_8h.html#a21">uint32</a> minIndex = 0;
00904       <a class="code" href="Types_8h.html#a21">uint32</a> nbrElements = m_nbrUsed[m_heapStartIndex];
00905       <a class="code" href="classRoutingNode.html">RoutingNode</a>** minimumCostBucket = m_matrix[m_heapStartIndex];
00906       
00907       <span class="keywordflow">for</span> (<a class="code" href="Types_8h.html#a21">uint32</a> i = 0; i &lt; nbrElements; i++) {      
00908          tempNode = minimumCostBucket[i];
00909          <span class="keywordflow">if</span> (tempNode-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(m_map) &lt; minCost) {
00910             minCost  = tempNode-&gt;<a class="code" href="classRoutingNode.html#a7">getEstCost</a>(m_map);
00911             minNode  = tempNode;
00912             minIndex = i;
00913          }
00914       }
00915       
00916       minimumCostBucket[minIndex] = minimumCostBucket[nbrElements - 1];
00917       m_nbrUsed[m_heapStartIndex]--;
00918    }
00919    <a class="code" href="classBucketHeap.html#r3">m_totalNbrUsed</a>--;
00920 
00921    <span class="keywordflow">return</span> minNode;
00922 } <span class="comment">// dequeue</span>
00923 <span class="preprocessor">#endif // OLD_BUCKET_HEAP</span>
00924 <span class="preprocessor"></span>
00925 <span class="comment">// Common functions for old and new bucketheap</span>
00926 
00927 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00928"></a><a class="code" href="classBucketHeap.html#a6">00928</a> <a class="code" href="classBucketHeap.html#a6">BucketHeap::updateStartIndex</a>(uint32 cost)
00929 {
00930    <span class="keywordflow">if</span>( cost &gt; BUCKET_COST_DIFFERENCE ){
00931       <span class="keywordflow">while</span> (<a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> &lt; (cost - BUCKET_COST_DIFFERENCE)) {
00932          <a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a>++;
00933          <span class="keywordflow">if</span>(<a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> == ROWS)
00934             <a class="code" href="classBucketHeap.html#r1">m_heapStartIndex</a> = 0;
00935          <a class="code" href="classBucketHeap.html#r2">m_leastExpectedCostInHeap</a> += BUCKET_COST_DIFFERENCE;
00936       } 
00937    }
00938 }
00939    
00940 <span class="preprocessor">#endif // BUCKETHEAP_H</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:45 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
