<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: json_spirit_reader_template.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Server</a>&nbsp;/&nbsp;<a class="el" href="dir_000005.html">Shared</a>&nbsp;/&nbsp;<a class="el" href="dir_000053.html">JSON</a>&nbsp;/&nbsp;<a class="el" href="dir_000054.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000055.html">json_spirit</a></div>
<h1>json_spirit_reader_template.h</h1><a href="json__spirit__reader__template_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef JSON_SPIRIT_READER_TEMPLATE</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define JSON_SPIRIT_READER_TEMPLATE</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">//          Copyright John W. Wilkinson 2007 - 2009.</span>
00005 <span class="comment">// Distributed under the MIT License, see accompanying file LICENSE.txt</span>
00006 
00007 <span class="comment">// json spirit version 4.03</span>
00008 
00009 <span class="preprocessor">#include "<a class="code" href="json__spirit__value_8h.html">json_spirit/json_spirit_value.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="json__spirit__error__position_8h.html">json_spirit/json_spirit_error_position.h</a>"</span>
00011 
00012 <span class="comment">//#define BOOST_SPIRIT_THREADSAFE  // uncomment for multithreaded use, requires linking to boost.thread</span>
00013 
00014 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
00015 <span class="preprocessor">#include &lt;boost/function.hpp&gt;</span>
00016 <span class="preprocessor">#include &lt;boost/version.hpp&gt;</span>
00017 
00018 <span class="preprocessor">#if BOOST_VERSION &gt;= 103800</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;boost/spirit/include/classic_core.hpp&gt;</span>
00020 <span class="preprocessor">    #include &lt;boost/spirit/include/classic_confix.hpp&gt;</span>
00021 <span class="preprocessor">    #include &lt;boost/spirit/include/classic_escape_char.hpp&gt;</span>
00022 <span class="preprocessor">    #include &lt;boost/spirit/include/classic_multi_pass.hpp&gt;</span>
00023 <span class="preprocessor">    #include &lt;boost/spirit/include/classic_position_iterator.hpp&gt;</span>
00024 <span class="preprocessor">    #define spirit_namespace boost::spirit::classic</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00026 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;boost/spirit/core.hpp&gt;</span>
00027 <span class="preprocessor">    #include &lt;boost/spirit/utility/confix.hpp&gt;</span>
00028 <span class="preprocessor">    #include &lt;boost/spirit/utility/escape_char.hpp&gt;</span>
00029 <span class="preprocessor">    #include &lt;boost/spirit/iterator/multi_pass.hpp&gt;</span>
00030 <span class="preprocessor">    #include &lt;boost/spirit/iterator/position_iterator.hpp&gt;</span>
<a name="l00031"></a><a class="code" href="json__spirit__reader__template_8h.html#a0">00031</a> <span class="preprocessor">    #define spirit_namespace boost::spirit</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="keyword">namespace </span>json_spirit
00035 {
<a name="l00036"></a><a class="code" href="namespacejson__spirit.html#a0">00036</a>     <span class="keyword">const</span> spirit_namespace::int_parser &lt; boost::int64_t &gt;  <a class="code" href="namespacejson__spirit.html#a0">int64_p</a>  = spirit_namespace::int_parser &lt; boost::int64_t  &gt;();
<a name="l00037"></a><a class="code" href="namespacejson__spirit.html#a1">00037</a>     <span class="keyword">const</span> spirit_namespace::uint_parser&lt; boost::uint64_t &gt; <a class="code" href="namespacejson__spirit.html#a1">uint64_p</a> = spirit_namespace::uint_parser&lt; boost::uint64_t &gt;();
00038 
00039     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Iter_type &gt;
<a name="l00040"></a><a class="code" href="namespacejson__spirit.html#a29">00040</a>     <span class="keywordtype">bool</span> <a class="code" href="namespacejson__spirit.html#a29">is_eq</a>( Iter_type first, Iter_type last, <span class="keyword">const</span> <span class="keywordtype">char</span>* c_str )
00041     {
00042         <span class="keywordflow">for</span>( Iter_type i = first; i != last; ++i, ++c_str )
00043         {
00044             <span class="keywordflow">if</span>( *c_str == 0 ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00045 
00046             <span class="keywordflow">if</span>( *i != *c_str ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00047         }
00048 
00049         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00050     }
00051 
00052     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Char_type &gt;
<a name="l00053"></a><a class="code" href="namespacejson__spirit.html#a30">00053</a>     Char_type <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( <span class="keyword">const</span> Char_type c )
00054     {
00055         <span class="keywordflow">if</span>( ( c &gt;= <span class="charliteral">'0'</span> ) &amp;&amp; ( c &lt;= <span class="charliteral">'9'</span> ) ) <span class="keywordflow">return</span> c - <span class="charliteral">'0'</span>;
00056         <span class="keywordflow">if</span>( ( c &gt;= <span class="charliteral">'a'</span> ) &amp;&amp; ( c &lt;= <span class="charliteral">'f'</span> ) ) <span class="keywordflow">return</span> c - <span class="charliteral">'a'</span> + 10;
00057         <span class="keywordflow">if</span>( ( c &gt;= <span class="charliteral">'A'</span> ) &amp;&amp; ( c &lt;= <span class="charliteral">'F'</span> ) ) <span class="keywordflow">return</span> c - <span class="charliteral">'A'</span> + 10;
00058         <span class="keywordflow">return</span> 0;
00059     }
00060 
00061     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Char_type, <span class="keyword">class</span> Iter_type &gt;
<a name="l00062"></a><a class="code" href="namespacejson__spirit.html#a31">00062</a>     Char_type <a class="code" href="namespacejson__spirit.html#a31">hex_str_to_char</a>( Iter_type&amp; begin )
00063     {
00064         <span class="keyword">const</span> Char_type c1( *( ++begin ) );
00065         <span class="keyword">const</span> Char_type c2( *( ++begin ) );
00066 
00067         <span class="keywordflow">return</span> ( <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c1 ) &lt;&lt; 4 ) + <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c2 );
00068     }       
00069 
00070     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Char_type, <span class="keyword">class</span> Iter_type &gt;
<a name="l00071"></a><a class="code" href="namespacejson__spirit.html#a32">00071</a>     Char_type <a class="code" href="namespacejson__spirit.html#a32">unicode_str_to_char</a>( Iter_type&amp; begin )
00072     {
00073         <span class="keyword">const</span> Char_type c1( *( ++begin ) );
00074         <span class="keyword">const</span> Char_type c2( *( ++begin ) );
00075         <span class="keyword">const</span> Char_type c3( *( ++begin ) );
00076         <span class="keyword">const</span> Char_type c4( *( ++begin ) );
00077 
00078         <span class="keywordflow">return</span> ( <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c1 ) &lt;&lt; 12 ) + 
00079                ( <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c2 ) &lt;&lt;  8 ) + 
00080                ( <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c3 ) &lt;&lt;  4 ) + 
00081                <a class="code" href="namespacejson__spirit.html#a30">hex_to_num</a>( c4 );
00082     }
00083 
00084     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type &gt;
<a name="l00085"></a><a class="code" href="namespacejson__spirit.html#a33">00085</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a33">append_esc_char_and_incr_iter</a>( String_type&amp; s, 
00086                                         <span class="keyword">typename</span> String_type::const_iterator&amp; begin, 
00087                                         <span class="keyword">typename</span> String_type::const_iterator end )
00088     {
00089         <span class="keyword">typedef</span> <span class="keyword">typename</span> String_type::value_type Char_type;
00090              
00091         <span class="keyword">const</span> Char_type c2( *begin );
00092 
00093         <span class="keywordflow">switch</span>( c2 )
00094         {
00095             <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:  s += <span class="charliteral">'\t'</span>; <span class="keywordflow">break</span>;
00096             <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:  s += <span class="charliteral">'\b'</span>; <span class="keywordflow">break</span>;
00097             <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:  s += <span class="charliteral">'\f'</span>; <span class="keywordflow">break</span>;
00098             <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:  s += <span class="charliteral">'\n'</span>; <span class="keywordflow">break</span>;
00099             <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:  s += <span class="charliteral">'\r'</span>; <span class="keywordflow">break</span>;
00100             <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>: s += <span class="charliteral">'\\'</span>; <span class="keywordflow">break</span>;
00101             <span class="keywordflow">case</span> <span class="charliteral">'/'</span>:  s += <span class="charliteral">'/'</span>;  <span class="keywordflow">break</span>;
00102             <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:  s += <span class="charliteral">'"'</span>;  <span class="keywordflow">break</span>;
00103             <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:  
00104             {
00105                 <span class="keywordflow">if</span>( end - begin &gt;= 3 )  <span class="comment">//  expecting "xHH..."</span>
00106                 {
00107                     s += hex_str_to_char&lt; Char_type &gt;( begin );  
00108                 }
00109                 <span class="keywordflow">break</span>;
00110             }
00111             <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:  
00112             {
00113                 <span class="keywordflow">if</span>( end - begin &gt;= 5 )  <span class="comment">//  expecting "uHHHH..."</span>
00114                 {
00115                     s += unicode_str_to_char&lt; Char_type &gt;( begin );  
00116                 }
00117                 <span class="keywordflow">break</span>;
00118             }
00119         }
00120     }
00121 
00122     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type &gt;
<a name="l00123"></a><a class="code" href="namespacejson__spirit.html#a34">00123</a>     String_type <a class="code" href="namespacejson__spirit.html#a34">substitute_esc_chars</a>( <span class="keyword">typename</span> String_type::const_iterator begin, 
00124                                    <span class="keyword">typename</span> String_type::const_iterator end )
00125     {
00126         <span class="keyword">typedef</span> <span class="keyword">typename</span> String_type::const_iterator Iter_type;
00127 
00128         <span class="keywordflow">if</span>( end - begin &lt; 2 ) <span class="keywordflow">return</span> String_type( begin, end );
00129 
00130         String_type result;
00131         
00132         result.reserve( end - begin );
00133 
00134         <span class="keyword">const</span> Iter_type end_minus_1( end - 1 );
00135 
00136         Iter_type substr_start = begin;
00137         Iter_type i = begin;
00138 
00139         <span class="keywordflow">for</span>( ; i &lt; end_minus_1; ++i )
00140         {
00141             <span class="keywordflow">if</span>( *i == <span class="charliteral">'\\'</span> )
00142             {
00143                 result.append( substr_start, i );
00144 
00145                 ++i;  <span class="comment">// skip the '\'</span>
00146              
00147                 <a class="code" href="namespacejson__spirit.html#a33">append_esc_char_and_incr_iter</a>( result, i, end );
00148 
00149                 substr_start = i + 1;
00150             }
00151         }
00152 
00153         result.append( substr_start, end );
00154 
00155         <span class="keywordflow">return</span> result;
00156     }
00157 
00158     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type &gt;
<a name="l00159"></a><a class="code" href="namespacejson__spirit.html#a35">00159</a>     String_type <a class="code" href="namespacejson__spirit.html#a35">get_str_</a>( <span class="keyword">typename</span> String_type::const_iterator begin, 
00160                        <span class="keyword">typename</span> String_type::const_iterator end )
00161     {
00162         assert( end - begin &gt;= 2 );
00163 
00164         <span class="keyword">typedef</span> <span class="keyword">typename</span> String_type::const_iterator Iter_type;
00165 
00166         Iter_type str_without_quotes( ++begin );
00167         Iter_type end_without_quotes( --end );
00168 
00169         <span class="keywordflow">return</span> substitute_esc_chars&lt; String_type &gt;( str_without_quotes, end_without_quotes );
00170     }
00171 
<a name="l00172"></a><a class="code" href="namespacejson__spirit.html#a36">00172</a>     <span class="keyword">inline</span> std::string <a class="code" href="namespacejson__spirit.html#a38">get_str</a>( std::string::const_iterator begin, std::string::const_iterator end )
00173     {
00174         <span class="keywordflow">return</span> get_str_&lt; std::string &gt;( begin, end );
00175     }
00176 
<a name="l00177"></a><a class="code" href="namespacejson__spirit.html#a37">00177</a>     <span class="keyword">inline</span> std::wstring <a class="code" href="namespacejson__spirit.html#a38">get_str</a>( std::wstring::const_iterator begin, std::wstring::const_iterator end )
00178     {
00179         <span class="keywordflow">return</span> get_str_&lt; std::wstring &gt;( begin, end );
00180     }
00181     
00182     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type, <span class="keyword">class</span> Iter_type &gt;
<a name="l00183"></a><a class="code" href="namespacejson__spirit.html#a38">00183</a>     String_type <a class="code" href="namespacejson__spirit.html#a38">get_str</a>( Iter_type begin, Iter_type end )
00184     {
00185         <span class="keyword">const</span> String_type tmp( begin, end );  <span class="comment">// convert multipass iterators to string iterators</span>
00186 
00187         <span class="keywordflow">return</span> <a class="code" href="namespacejson__spirit.html#a38">get_str</a>( tmp.begin(), tmp.end() );
00188     }
00189 
00190     <span class="comment">// this class's methods get called by the spirit parse resulting</span>
00191     <span class="comment">// in the creation of a JSON object or array</span>
00192     <span class="comment">//</span>
00193     <span class="comment">// NB Iter_type could be a std::string iterator, wstring iterator, a position iterator or a multipass iterator</span>
00194     <span class="comment">//</span>
00195     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Value_type, <span class="keyword">class</span> Iter_type &gt;
<a name="l00196"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html">00196</a>     <span class="keyword">class </span><a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions</a> 
00197     {
00198     <span class="keyword">public</span>:
00199 
<a name="l00200"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#w0">00200</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> Value_type::Config_type Config_type;
<a name="l00201"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#w1">00201</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> Config_type::String_type String_type;
<a name="l00202"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#w2">00202</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> Config_type::Object_type Object_type;
<a name="l00203"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#w3">00203</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> Config_type::Array_type Array_type;
<a name="l00204"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#w4">00204</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> String_type::value_type Char_type;
00205 
<a name="l00206"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a0">00206</a>         <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions</a>( Value_type&amp; value )
00207         :   value_( value )
00208         ,   current_p_( 0 )
00209         {
00210         }
00211 
<a name="l00212"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a1">00212</a>         <span class="keywordtype">void</span> begin_obj( Char_type c )
00213         {
00214             assert( c == <span class="charliteral">'{'</span> );
00215 
00216             begin_compound&lt; Object_type &gt;();
00217         }
00218 
<a name="l00219"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a2">00219</a>         <span class="keywordtype">void</span> end_obj( Char_type c )
00220         {
00221             assert( c == <span class="charliteral">'}'</span> );
00222 
00223             end_compound();
00224         }
00225 
<a name="l00226"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a3">00226</a>         <span class="keywordtype">void</span> begin_array( Char_type c )
00227         {
00228             assert( c == <span class="charliteral">'['</span> );
00229      
00230             begin_compound&lt; Array_type &gt;();
00231         }
00232 
<a name="l00233"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a4">00233</a>         <span class="keywordtype">void</span> end_array( Char_type c )
00234         {
00235             assert( c == <span class="charliteral">']'</span> );
00236 
00237             end_compound();
00238         }
00239 
<a name="l00240"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a5">00240</a>         <span class="keywordtype">void</span> new_name( Iter_type begin, Iter_type end )
00241         {
00242             assert( current_p_-&gt;type() == obj_type );
00243 
00244             name_ = get_str&lt; String_type &gt;( begin, end );
00245         }
00246 
<a name="l00247"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a6">00247</a>         <span class="keywordtype">void</span> new_str( Iter_type begin, Iter_type end )
00248         {
00249             add_to_current( get_str&lt; String_type &gt;( begin, end ) );
00250         }
00251 
<a name="l00252"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a7">00252</a>         <span class="keywordtype">void</span> new_true( Iter_type begin, Iter_type end )
00253         {
00254             assert( <a class="code" href="namespacejson__spirit.html#a29">is_eq</a>( begin, end, <span class="stringliteral">"true"</span> ) );
00255 
00256             add_to_current( <span class="keyword">true</span> );
00257         }
00258 
<a name="l00259"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a8">00259</a>         <span class="keywordtype">void</span> new_false( Iter_type begin, Iter_type end )
00260         {
00261             assert( <a class="code" href="namespacejson__spirit.html#a29">is_eq</a>( begin, end, <span class="stringliteral">"false"</span> ) );
00262 
00263             add_to_current( <span class="keyword">false</span> );
00264         }
00265 
<a name="l00266"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a9">00266</a>         <span class="keywordtype">void</span> new_null( Iter_type begin, Iter_type end )
00267         {
00268             assert( <a class="code" href="namespacejson__spirit.html#a29">is_eq</a>( begin, end, <span class="stringliteral">"null"</span> ) );
00269 
00270             add_to_current( <a class="code" href="namespacejson__spirit.html#a58">Value_type</a>() );
00271         }
00272 
<a name="l00273"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a10">00273</a>         <span class="keywordtype">void</span> new_int( boost::int64_t i )
00274         {
00275             add_to_current( i );
00276         }
00277 
<a name="l00278"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a11">00278</a>         <span class="keywordtype">void</span> new_uint64( boost::uint64_t ui )
00279         {
00280             add_to_current( ui );
00281         }
00282 
<a name="l00283"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#a12">00283</a>         <span class="keywordtype">void</span> new_real( <span class="keywordtype">double</span> d )
00284         {
00285             add_to_current( d );
00286         }
00287 
00288     <span class="keyword">private</span>:
00289 
00290         <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions</a>&amp; ); 
00291                                     <span class="comment">// to prevent "assignment operator could not be generated" warning</span>
00292 
<a name="l00293"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#d1">00293</a>         <a class="code" href="namespacejson__spirit.html#a58">Value_type</a>* add_first( <span class="keyword">const</span> Value_type&amp; value )
00294         {
00295             assert( current_p_ == 0 );
00296 
00297             value_ = value;
00298             current_p_ = &amp;value_;
00299             <span class="keywordflow">return</span> current_p_;
00300         }
00301 
00302         <span class="keyword">template</span>&lt; <span class="keyword">class</span> Array_or_obj &gt;
<a name="l00303"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#d2">00303</a>         <span class="keywordtype">void</span> begin_compound()
00304         {
00305             <span class="keywordflow">if</span>( current_p_ == 0 )
00306             {
00307                 add_first( Array_or_obj() );
00308             }
00309             <span class="keywordflow">else</span>
00310             {
00311                 stack_.push_back( current_p_ );
00312 
00313                 Array_or_obj new_array_or_obj;   <span class="comment">// avoid copy by building new array or object in place</span>
00314 
00315                 current_p_ = add_to_current( new_array_or_obj );
00316             }
00317         }
00318 
<a name="l00319"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#d3">00319</a>         <span class="keywordtype">void</span> end_compound()
00320         {
00321             <span class="keywordflow">if</span>( current_p_ != &amp;value_ )
00322             {
00323                 current_p_ = stack_.back();
00324                 
00325                 stack_.pop_back();
00326             }    
00327         }
00328 
<a name="l00329"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#d4">00329</a>         <a class="code" href="namespacejson__spirit.html#a58">Value_type</a>* add_to_current( <span class="keyword">const</span> Value_type&amp; value )
00330         {
00331             <span class="keywordflow">if</span>( current_p_ == 0 )
00332             {
00333                 <span class="keywordflow">return</span> add_first( value );
00334             }
00335             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( current_p_-&gt;type() == array_type )
00336             {
00337                 current_p_-&gt;get_array().push_back( value );
00338 
00339                 <span class="keywordflow">return</span> &amp;current_p_-&gt;get_array().back(); 
00340             }
00341             
00342             assert( current_p_-&gt;type() == obj_type );
00343 
00344             <span class="keywordflow">return</span> &amp;Config_type::add( current_p_-&gt;get_obj(), name_, value );
00345         }
00346 
<a name="l00347"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#r0">00347</a>         <a class="code" href="namespacejson__spirit.html#a58">Value_type</a>&amp; value_;             <span class="comment">// this is the object or array that is being created</span>
<a name="l00348"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#r1">00348</a>         <a class="code" href="namespacejson__spirit.html#a58">Value_type</a>* current_p_;         <span class="comment">// the child object or array that is currently being constructed</span>
00349 
<a name="l00350"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#r2">00350</a>         std::vector&lt; Value_type* &gt; stack_;   <span class="comment">// previous child objects and arrays</span>
00351 
<a name="l00352"></a><a class="code" href="classjson__spirit_1_1Semantic__actions.html#r3">00352</a>         String_type name_;              <span class="comment">// of current name/value pair</span>
00353     };
00354 
00355     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Iter_type &gt;
<a name="l00356"></a><a class="code" href="namespacejson__spirit.html#a39">00356</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( spirit_namespace::position_iterator&lt; Iter_type &gt; i, <span class="keyword">const</span> std::string&amp; reason )
00357     {
00358         <span class="keywordflow">throw</span> <a class="code" href="structjson__spirit_1_1Error__position.html">Error_position</a>( i.get_position().line, i.get_position().column, reason );
00359     }
00360 
00361     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Iter_type &gt;
<a name="l00362"></a><a class="code" href="namespacejson__spirit.html#a40">00362</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( Iter_type i, <span class="keyword">const</span> std::string&amp; reason )
00363     {
00364        <span class="keywordflow">throw</span> reason;
00365     }
00366 
00367     <span class="comment">// the spirit grammer </span>
00368     <span class="comment">//</span>
00369     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Value_type, <span class="keyword">class</span> Iter_type &gt;
<a name="l00370"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html">00370</a>     <span class="keyword">class </span><a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer</a> : <span class="keyword">public</span> <a class="code" href="json__spirit__reader__template_8h.html#a0">spirit_namespace</a>::grammar&lt; Json_grammer&lt; Value_type, Iter_type &gt; &gt;
00371     {
00372     <span class="keyword">public</span>:
00373 
<a name="l00374"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#w0">00374</a>         <span class="keyword">typedef</span> <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions&lt; Value_type, Iter_type &gt;</a> <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions_t</a>;
00375 
<a name="l00376"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#a0">00376</a>         <a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer</a>( <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions_t</a>&amp; semantic_actions )
00377         :   actions_( semantic_actions )
00378         {
00379         }
00380 
<a name="l00381"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e0">00381</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_value( Iter_type begin, Iter_type end )
00382         {
00383           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"not a value"</span> );
00384         }
00385 
<a name="l00386"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e1">00386</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_array( Iter_type begin, Iter_type end )
00387         {
00388           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"not an array"</span> );
00389         }
00390 
<a name="l00391"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e2">00391</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_object( Iter_type begin, Iter_type end )
00392         {
00393           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"not an object"</span> );
00394         }
00395 
<a name="l00396"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e3">00396</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_pair( Iter_type begin, Iter_type end )
00397         {
00398           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"not a pair"</span> );
00399         }
00400 
<a name="l00401"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e4">00401</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_colon( Iter_type begin, Iter_type end )
00402         {
00403           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"no colon in pair"</span> );
00404         }
00405 
<a name="l00406"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#e5">00406</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> throw_not_string( Iter_type begin, Iter_type end )
00407         {
00408           <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( begin, <span class="stringliteral">"not a string"</span> );
00409         }
00410 
00411         <span class="keyword">template</span>&lt; <span class="keyword">typename</span> ScannerT &gt;
<a name="l00412"></a><a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html">00412</a>         <span class="keyword">class </span><a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html">definition</a>
00413         {
00414         <span class="keyword">public</span>:
00415 
<a name="l00416"></a><a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html#a0">00416</a>             <a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html">definition</a>( <span class="keyword">const</span> <a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer</a>&amp; <span class="keyword">self</span> )
00417             {
00418                 <span class="keyword">using</span> <span class="keyword">namespace </span><a class="code" href="json__spirit__reader__template_8h.html#a0">spirit_namespace</a>;
00419 
00420                 <span class="keyword">typedef</span> <span class="keyword">typename</span> Value_type::String_type::value_type Char_type;
00421 
00422                 <span class="comment">// first we convert the semantic action class methods to functors with the </span>
00423                 <span class="comment">// parameter signature expected by spirit</span>
00424 
00425                 <span class="keyword">typedef</span> boost::function&lt; void( Char_type )            &gt; Char_action;
00426                 <span class="keyword">typedef</span> boost::function&lt; void( Iter_type, Iter_type ) &gt; Str_action;
00427                 <span class="keyword">typedef</span> boost::function&lt; void( double )               &gt; Real_action;
00428                 <span class="keyword">typedef</span> boost::function&lt; void( boost::int64_t )       &gt; Int_action;
00429                 <span class="keyword">typedef</span> boost::function&lt; void( boost::uint64_t )      &gt; Uint64_action;
00430 
00431                 Char_action   begin_obj  ( boost::bind( &amp;Semantic_actions_t::begin_obj,   &amp;<span class="keyword">self</span>.actions_, _1 ) );
00432                 Char_action   end_obj    ( boost::bind( &amp;Semantic_actions_t::end_obj,     &amp;<span class="keyword">self</span>.actions_, _1 ) );
00433                 Char_action   begin_array( boost::bind( &amp;Semantic_actions_t::begin_array, &amp;<span class="keyword">self</span>.actions_, _1 ) );
00434                 Char_action   end_array  ( boost::bind( &amp;Semantic_actions_t::end_array,   &amp;<span class="keyword">self</span>.actions_, _1 ) );
00435                 Str_action    new_name   ( boost::bind( &amp;Semantic_actions_t::new_name,    &amp;<span class="keyword">self</span>.actions_, _1, _2 ) );
00436                 Str_action    new_str    ( boost::bind( &amp;Semantic_actions_t::new_str,     &amp;<span class="keyword">self</span>.actions_, _1, _2 ) );
00437                 Str_action    new_true   ( boost::bind( &amp;Semantic_actions_t::new_true,    &amp;<span class="keyword">self</span>.actions_, _1, _2 ) );
00438                 Str_action    new_false  ( boost::bind( &amp;Semantic_actions_t::new_false,   &amp;<span class="keyword">self</span>.actions_, _1, _2 ) );
00439                 Str_action    new_null   ( boost::bind( &amp;Semantic_actions_t::new_null,    &amp;<span class="keyword">self</span>.actions_, _1, _2 ) );
00440                 Real_action   new_real   ( boost::bind( &amp;Semantic_actions_t::new_real,    &amp;<span class="keyword">self</span>.actions_, _1 ) );
00441                 Int_action    new_int    ( boost::bind( &amp;Semantic_actions_t::new_int,     &amp;<span class="keyword">self</span>.actions_, _1 ) );
00442                 Uint64_action new_uint64 ( boost::bind( &amp;Semantic_actions_t::new_uint64,  &amp;<span class="keyword">self</span>.actions_, _1 ) );
00443 
00444                 <span class="comment">// actual grammer</span>
00445 
00446                 json_
00447                     = value_ | eps_p[ &amp;throw_not_value ]
00448                     ;
00449 
00450                 value_
00451                     = string_[ new_str ] 
00452                     | number_ 
00453                     | object_ 
00454                     | array_ 
00455                     | str_p( <span class="stringliteral">"true"</span> ) [ new_true  ] 
00456                     | str_p( <span class="stringliteral">"false"</span> )[ new_false ] 
00457                     | str_p( <span class="stringliteral">"null"</span> ) [ new_null  ]
00458                     ;
00459 
00460                 object_ 
00461                     = ch_p(<span class="charliteral">'{'</span>)[ begin_obj ]
00462                     &gt;&gt; !members_
00463                     &gt;&gt; ( ch_p(<span class="charliteral">'}'</span>)[ end_obj ] | eps_p[ &amp;throw_not_object ] )
00464                     ;
00465 
00466                 members_
00467                     = pair_ &gt;&gt; *( <span class="charliteral">','</span> &gt;&gt; pair_ )
00468                     ;
00469 
00470                 pair_
00471                     = string_[ new_name ]
00472                     &gt;&gt; ( <span class="charliteral">':'</span> | eps_p[ &amp;throw_not_colon ] )
00473                     &gt;&gt; ( value_ | eps_p[ &amp;throw_not_value ] )
00474                     ;
00475 
00476                 array_
00477                     = ch_p(<span class="charliteral">'['</span>)[ begin_array ]
00478                     &gt;&gt; !elements_
00479                     &gt;&gt; ( ch_p(<span class="charliteral">']'</span>)[ end_array ] | eps_p[ &amp;throw_not_array ] )
00480                     ;
00481 
00482                 elements_
00483                     = value_ &gt;&gt; *( <span class="charliteral">','</span> &gt;&gt; value_ )
00484                     ;
00485 
00486                 string_ 
00487                     = lexeme_d <span class="comment">// this causes white space inside a string to be retained</span>
00488                       [
00489                           confix_p
00490                           ( 
00491                               <span class="charliteral">'"'</span>, 
00492                               *lex_escape_ch_p,
00493                               <span class="charliteral">'"'</span>
00494                           ) 
00495                       ]
00496                     ;
00497 
00498                 number_
00499                     = strict_real_p[ new_real   ] 
00500                     | <a class="code" href="namespacejson__spirit.html#a0">int64_p</a>      [ new_int    ]
00501                     | <a class="code" href="namespacejson__spirit.html#a1">uint64_p</a>     [ new_uint64 ]
00502                     ;
00503             }
00504 
<a name="l00505"></a><a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html#o6">00505</a>             spirit_namespace::rule&lt; ScannerT &gt; json_, object_, members_, pair_, array_, elements_, value_, string_, number_;
00506 
<a name="l00507"></a><a class="code" href="classjson__spirit_1_1Json__grammer_1_1definition.html#a1">00507</a>             <span class="keyword">const</span> spirit_namespace::rule&lt; ScannerT &gt;&amp; start()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> json_; }
00508         };
00509 
00510     <span class="keyword">private</span>:
00511 
00512         <a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer</a>&amp; ); <span class="comment">// to prevent "assignment operator could not be generated" warning</span>
00513 
<a name="l00514"></a><a class="code" href="classjson__spirit_1_1Json__grammer.html#r0">00514</a>         <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions_t</a>&amp; actions_;
00515     };
00516 
00517     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Iter_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00518"></a><a class="code" href="namespacejson__spirit.html#a41">00518</a>     Iter_type <a class="code" href="namespacejson__spirit.html#a41">read_range_or_throw</a>( Iter_type begin, Iter_type end, Value_type&amp; value )
00519     {
00520         <a class="code" href="classjson__spirit_1_1Semantic__actions.html">Semantic_actions&lt; Value_type, Iter_type &gt;</a> semantic_actions( value );
00521      
00522         <span class="keyword">const</span> spirit_namespace::parse_info&lt; Iter_type &gt; <a class="code" href="MC2Logging_8h.html#a14">info</a> = 
00523                             spirit_namespace::parse( begin, end, 
00524                                                     <a class="code" href="classjson__spirit_1_1Json__grammer.html">Json_grammer&lt; Value_type, Iter_type &gt;</a>( semantic_actions ), 
00525                                                     spirit_namespace::space_p );
00526 
00527         <span class="keywordflow">if</span>( !<a class="code" href="MC2Logging_8h.html#a14">info</a>.hit )
00528         {
00529             assert( <span class="keyword">false</span> ); <span class="comment">// in theory exception should already have been thrown</span>
00530             <a class="code" href="namespacejson__spirit.html#a40">throw_error</a>( <a class="code" href="MC2Logging_8h.html#a14">info</a>.stop, <span class="stringliteral">"error"</span> );
00531         }
00532 
00533         <span class="keywordflow">return</span> <a class="code" href="MC2Logging_8h.html#a14">info</a>.stop;
00534     }
00535 
00536     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Iter_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00537"></a><a class="code" href="namespacejson__spirit.html#a42">00537</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a42">add_posn_iter_and_read_range_or_throw</a>( Iter_type begin, Iter_type end, Value_type&amp; value )
00538     {
00539         <span class="keyword">typedef</span> spirit_namespace::position_iterator&lt; Iter_type &gt; Posn_iter_t;
00540 
00541         <span class="keyword">const</span> Posn_iter_t posn_begin( begin, end );
00542         <span class="keyword">const</span> Posn_iter_t posn_end( end, end );
00543      
00544         <a class="code" href="namespacejson__spirit.html#a41">read_range_or_throw</a>( posn_begin, posn_end, value );
00545     }
00546 
00547     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Iter_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00548"></a><a class="code" href="namespacejson__spirit.html#a43">00548</a>     <span class="keywordtype">bool</span> <a class="code" href="namespacejson__spirit.html#a43">read_range</a>( Iter_type&amp; begin, Iter_type end, Value_type&amp; value )
00549     {
00550         <span class="keywordflow">try</span>
00551         {
00552             begin = <a class="code" href="namespacejson__spirit.html#a41">read_range_or_throw</a>( begin, end, value );
00553 
00554             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00555         }
00556         <span class="keywordflow">catch</span>( ... )
00557         {
00558             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00559         }
00560     }
00561 
00562     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00563"></a><a class="code" href="namespacejson__spirit.html#a44">00563</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a44">read_string_or_throw</a>( <span class="keyword">const</span> String_type&amp; s, Value_type&amp; value )
00564     {
00565         <a class="code" href="namespacejson__spirit.html#a42">add_posn_iter_and_read_range_or_throw</a>( s.begin(), s.end(), value );
00566     }
00567 
00568     <span class="keyword">template</span>&lt; <span class="keyword">class</span> String_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00569"></a><a class="code" href="namespacejson__spirit.html#a45">00569</a>     <span class="keywordtype">bool</span> <a class="code" href="namespacejson__spirit.html#a45">read_string</a>( <span class="keyword">const</span> String_type&amp; s, Value_type&amp; value )
00570     {
00571         <span class="keyword">typename</span> String_type::const_iterator begin = s.begin();
00572 
00573         <span class="keywordflow">return</span> <a class="code" href="namespacejson__spirit.html#a43">read_range</a>( begin, s.end(), value );
00574     }
00575 
00576     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Istream_type &gt;
<a name="l00577"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html">00577</a>     <span class="keyword">struct </span><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html">Multi_pass_iters</a>
00578     {
<a name="l00579"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#w0">00579</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> Istream_type::char_type Char_type;
<a name="l00580"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#w1">00580</a>         <span class="keyword">typedef</span> std::istream_iterator&lt; Char_type, Char_type &gt; istream_iter;
<a name="l00581"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#w2">00581</a>         <span class="keyword">typedef</span> spirit_namespace::multi_pass&lt; istream_iter &gt; Mp_iter;
00582 
<a name="l00583"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#a0">00583</a>         <a class="code" href="structjson__spirit_1_1Multi__pass__iters.html">Multi_pass_iters</a>( Istream_type&amp; is )
00584         {
00585             is.unsetf( std::ios::skipws );
00586 
00587             begin_ = spirit_namespace::make_multi_pass( istream_iter( is ) );
00588             end_   = spirit_namespace::make_multi_pass( istream_iter() );
00589         }
00590 
<a name="l00591"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o0">00591</a>         Mp_iter begin_;
<a name="l00592"></a><a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o1">00592</a>         Mp_iter end_;
00593     };
00594 
00595     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Istream_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00596"></a><a class="code" href="namespacejson__spirit.html#a46">00596</a>     <span class="keywordtype">bool</span> <a class="code" href="namespacejson__spirit.html#a46">read_stream</a>( Istream_type&amp; is, Value_type&amp; value )
00597     {
00598         <a class="code" href="structjson__spirit_1_1Multi__pass__iters.html">Multi_pass_iters&lt; Istream_type &gt;</a> mp_iters( is );
00599 
00600         <span class="keywordflow">return</span> <a class="code" href="namespacejson__spirit.html#a43">read_range</a>( mp_iters.<a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o0">begin_</a>, mp_iters.<a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o1">end_</a>, value );
00601     }
00602 
00603     <span class="keyword">template</span>&lt; <span class="keyword">class</span> Istream_type, <span class="keyword">class</span> Value_type &gt;
<a name="l00604"></a><a class="code" href="namespacejson__spirit.html#a47">00604</a>     <span class="keywordtype">void</span> <a class="code" href="namespacejson__spirit.html#a47">read_stream_or_throw</a>( Istream_type&amp; is, Value_type&amp; value )
00605     {
00606         <span class="keyword">const</span> <a class="code" href="structjson__spirit_1_1Multi__pass__iters.html">Multi_pass_iters&lt; Istream_type &gt;</a> mp_iters( is );
00607 
00608         <a class="code" href="namespacejson__spirit.html#a42">add_posn_iter_and_read_range_or_throw</a>( mp_iters.<a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o0">begin_</a>, mp_iters.<a class="code" href="structjson__spirit_1_1Multi__pass__iters.html#o1">end_</a>, value );
00609     }
00610 }
00611 
00612 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:47 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
