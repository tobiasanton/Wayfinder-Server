<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: VectorIndexTable.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Server</a>&nbsp;/&nbsp;<a class="el" href="dir_000005.html">Shared</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">include</a></div>
<h1>VectorIndexTable.h</h1><a href="VectorIndexTable_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (c) 1999 - 2010, Vodafone Group Services Ltd</span>
00003 <span class="comment">All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
00008 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
00009 <span class="comment">    * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
00010 <span class="comment"></span>
00011 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#ifndef VECTOR_INDEX_TABLE_H</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define VECTOR_INDEX_TABLE_H</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#include "<a class="code" href="config_8h.html">config.h</a>"</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="ItemComboTable_8h.html">ItemComboTable.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="DataBuffer_8h.html">DataBuffer.h</a>"</span>
00021 
00022 <span class="preprocessor">#include &lt;vector&gt;</span>
00023 
00028 <span class="keyword">template</span>&lt;<span class="keyword">class </span>VALUE_TYPE,
00029          <span class="keyword">class </span>VALUE_RW = <span class="keyword">typename</span> <a class="code" href="classLoaderTypeSelector.html">LoaderTypeSelector&lt;VALUE_TYPE&gt;</a>::loaderType &gt;
<a name="l00030"></a><a class="code" href="classVectorIndexTable.html">00030</a> <span class="keyword">class </span><a class="code" href="classVectorIndexTable.html">VectorIndexTable</a> {
00031 <span class="keyword">public</span>:
00032 
<a name="l00033"></a><a class="code" href="classVectorIndexTable.html#w0">00033</a>    <span class="keyword">typedef</span> <a class="code" href="classvector.html">vector&lt;VALUE_TYPE&gt;</a> <a class="code" href="classvector.html">valVect_t</a>;
<a name="l00034"></a><a class="code" href="classVectorIndexTable.html#w1">00034</a>    <span class="keyword">typedef</span> <a class="code" href="classmap.html">map&lt;uint32, valVect_t&gt;</a> <a class="code" href="classmap.html">valMap_t</a>;
<a name="l00035"></a><a class="code" href="classVectorIndexTable.html#w2">00035</a>    <span class="keyword">typedef</span> <a class="code" href="classmap.html">map&lt;valVect_t, uint32&gt;</a> <a class="code" href="classmap.html">addedMap_t</a>;
<a name="l00036"></a><a class="code" href="classVectorIndexTable.html#w3">00036</a>    <span class="keyword">typedef</span> <a class="code" href="classmap.html">map&lt;uint32,uint32&gt;</a> <a class="code" href="classmap.html">indexMap_t</a>;
<a name="l00037"></a><a class="code" href="classVectorIndexTable.html#w4">00037</a>    <span class="keyword">typedef</span> <span class="keyword">const</span> VALUE_TYPE* <a class="code" href="classVectorIndexTable.html#w4">const_iterator</a>;
<a name="l00038"></a><a class="code" href="classVectorIndexTable.html#w5">00038</a>    <span class="keyword">typedef</span> pair&lt;const_iterator, const_iterator&gt; range_t;
00039 
00041    <span class="keyword">enum</span> { offsetMask = 0xffffff };
00042 
<a name="l00047"></a><a class="code" href="classVectorIndexTable.html#a0">00047</a>    <a class="code" href="classVectorIndexTable.html">VectorIndexTable</a>( indexMap_t&amp; indeces,
00048                      <span class="keyword">const</span> valMap_t&amp; vals ) {
00049       m_array = NULL;
00050       setValues( indeces, vals );
00051    }
00052    
<a name="l00053"></a><a class="code" href="classVectorIndexTable.html#a1">00053</a>    <a class="code" href="classVectorIndexTable.html">VectorIndexTable</a>() : m_array( NULL ),
00054                         m_arraySize( 0 ) {
00055    }
00056 
<a name="l00057"></a><a class="code" href="classVectorIndexTable.html#a2">00057</a>    <span class="keywordtype">void</span> clear() {
00058       <span class="keyword">delete</span> [] m_array;
00059       m_arraySize = 0;
00060       m_array = NULL;
00061    }
00062    
<a name="l00063"></a><a class="code" href="classVectorIndexTable.html#a3">00063</a>    ~<a class="code" href="classVectorIndexTable.html">VectorIndexTable</a>() {
00064       clear();
00065    }
00066 
00067    
<a name="l00068"></a><a class="code" href="classVectorIndexTable.html#a4">00068</a>    <a class="code" href="Types_8h.html#a21">uint32</a> getOneIndex( <span class="keyword">const</span> valVect_t&amp; val,
00069                        addedMap_t&amp; added,
00070                        valVect_t&amp; resVect ) {
00071       <span class="keywordflow">if</span> ( val.empty() ) {
00072          <span class="comment">// So that all empty ones will be the same.</span>
00073          <span class="keywordflow">return</span> 0;
00074       }
00075 
00076       <span class="keyword">typename</span> addedMap_t::const_iterator findit = added.find( val );
00077 
00078       <span class="keywordflow">if</span> ( findit == added.end() ) {
00079          <span class="comment">// Add it</span>
00080          <a class="code" href="Types_8h.html#a21">uint32</a> pos = resVect.size();
00081          resVect.insert( resVect.end(), val.begin(), val.end() );
00082          added.insert( make_pair( val, pos ) );
00083          <span class="comment">// Try again ( and succeed )</span>
00084          <span class="keywordflow">return</span> getOneIndex( val, added, resVect );
00085       } <span class="keywordflow">else</span> {
00086          <span class="keywordflow">return</span> findit-&gt;second;
00087       }
00088    }
00089 
<a name="l00091"></a><a class="code" href="classVectorIndexTable.html#e0">00091</a>    <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> makeIdx( uint32 offset,
00092                           uint8 nbrEntries ) {
00093       <a class="code" href="config_8h.html#a29">MC2_ASSERT</a>( ( offset &amp; offsetMask ) == offset );
00094       <span class="keywordflow">return</span> offset | ( <a class="code" href="Types_8h.html#a21">uint32</a>(nbrEntries) &lt;&lt; 24 );
00095    }
00096    
<a name="l00097"></a><a class="code" href="classVectorIndexTable.html#a5">00097</a>    <span class="keywordtype">void</span> setValues( indexMap_t&amp; indeces,
00098                    <span class="keyword">const</span> valMap_t&amp; vals ) {
00099       
00100       valVect_t resVect;
00101       addedMap_t added;
00102       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> valMap_t::const_iterator it = vals.begin();
00103             it != vals.end();
00104             ++it ) {
00105          <a class="code" href="Types_8h.html#a21">uint32</a> curIdx = makeIdx( getOneIndex( it-&gt;second, added, resVect ),
00106                                   it-&gt;second.size() );
00107          indeces.insert( make_pair( it-&gt;first, curIdx ) );
00108       }
00109       <span class="comment">// Now make array.</span>
00110       m_arraySize = resVect.size();
00111       <span class="keyword">delete</span> [] m_array;
00112       m_array = <span class="keyword">new</span> VALUE_TYPE[ m_arraySize ];
00113       <span class="keywordflow">for</span> ( <a class="code" href="Types_8h.html#a21">uint32</a> i = 0; i &lt; m_arraySize; ++i ) {
00114          m_array[i] = resVect[i];
00115       }
00116       
00117       <span class="comment">// Test that it's working</span>
00118       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> valMap_t::const_iterator it = vals.begin();
00119             it != vals.end();
00120             ++it ) {
00121          range_t r = range( indeces[it-&gt;first] );
00122          <a class="code" href="classvector.html">vector&lt;VALUE_TYPE&gt;</a> test( r.first, r.second );
00123          <a class="code" href="config_8h.html#a29">MC2_ASSERT</a>( test == it-&gt;second );
00124       }
00125       
00126    }
00127 
<a name="l00128"></a><a class="code" href="classVectorIndexTable.html#a6">00128</a>    <a class="code" href="Types_8h.html#a21">uint32</a> getSizeInDataBuffer()<span class="keyword"> const </span>{
00129       <a class="code" href="Types_8h.html#a21">uint32</a> size =  4 + 4;
00130       <span class="keywordflow">for</span> ( <a class="code" href="Types_8h.html#a21">uint32</a> i = 0; i &lt; m_arraySize; ++i ) {
00131          size += VALUE_RW::getValSizeInDataBuffer( m_array[i] );
00132       }
00133       <a class="code" href="namespaceAlignUtility.html#a4">AlignUtility::alignLong</a>( size );
00134       <span class="keywordflow">return</span> size;
00135    }
00136    
00137    
<a name="l00138"></a><a class="code" href="classVectorIndexTable.html#a7">00138</a>    <span class="keywordtype">void</span> <a class="code" href="namespaceTileFeatureScaleRange.html#a3">save</a>( <a class="code" href="classDataBuffer.html">DataBuffer</a>&amp; buf )<span class="keyword"> const </span>{
00139       buf.<a class="code" href="classDataBuffer.html#a13">writeNextLong</a>( getSizeInDataBuffer() );
00140       buf.<a class="code" href="classDataBuffer.html#a13">writeNextLong</a>( m_arraySize );
00141       <span class="keywordflow">for</span> ( <a class="code" href="Types_8h.html#a21">uint32</a> i = 0; i &lt; m_arraySize; ++i ) {
00142          VALUE_RW::writeValue( buf, m_array[i] );         
00143       }
00144       buf.<a class="code" href="classDataBuffer.html#a32">alignToLongAndClear</a>();
00145    }
00146 
<a name="l00147"></a><a class="code" href="classVectorIndexTable.html#a8">00147</a>    <span class="keywordtype">void</span> <a class="code" href="namespaceTileFeatureScaleRange.html#a4">load</a>( <a class="code" href="classDataBuffer.html">DataBuffer</a>&amp; buf ) {
00148       clear();
00149       buf.<a class="code" href="classDataBuffer.html#a7">readNextLong</a>();
00150       buf.<a class="code" href="classDataBuffer.html#a7">readNextLong</a>( m_arraySize );
00151       m_array = <span class="keyword">new</span> VALUE_TYPE[ m_arraySize ];
00152       <span class="keywordflow">for</span> ( <a class="code" href="Types_8h.html#a21">uint32</a> i = 0; i &lt; m_arraySize; ++i ) {
00153          VALUE_RW::readValue( buf, m_array[i] );
00154       }
00155       buf.<a class="code" href="classDataBuffer.html#a33">alignToLong</a>();
00156    }
00157    
<a name="l00158"></a><a class="code" href="classVectorIndexTable.html#a9">00158</a>    const_iterator begin( uint32 idx )<span class="keyword"> const </span>{
00159       <span class="keywordflow">return</span> &amp; ( m_array[ idx &amp; offsetMask] );
00160    }
00161 
<a name="l00162"></a><a class="code" href="classVectorIndexTable.html#a10">00162</a>    const_iterator end( uint32 idx )<span class="keyword"> const </span>{
00163       <span class="keywordflow">return</span> begin( idx ) + (idx &gt;&gt; 24);
00164    }
00165 
<a name="l00166"></a><a class="code" href="classVectorIndexTable.html#a11">00166</a>    pair&lt;const_iterator, const_iterator&gt; range( uint32 idx )<span class="keyword"> const </span>{
00167       <span class="keywordflow">return</span> make_pair( begin(idx), end(idx) );
00168    }
00169 
<a name="l00170"></a><a class="code" href="classVectorIndexTable.html#e1">00170</a>    <span class="keyword">static</span> <a class="code" href="classmap.html">map&lt;uint32, vector&lt;uint32&gt;</a> &gt; test() {
00171       <span class="keywordtype">int</span> nbrVects = 10;   
00172       <span class="keyword">typename</span> <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;uint32&gt;</a><a class="code" href="classmap.html">::valMap_t</a> vects;
00173       <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> xox = 0; xox &lt; 3; ++xox ) {
00174          <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; nbrVects; ++i ) {
00175             <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> j = 0; j &lt; i; ++j ) {
00176                vects[xox*nbrVects + i].push_back( j );
00177             }
00178          }
00179       }
00180       nbrVects *= 3;
00181       <span class="comment">// Add 100 empty vectors</span>
00182       <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 100; ++i ) {
00183          vects[nbrVects] = <a class="code" href="classvector.html">vector&lt;uint32&gt;</a>();
00184          ++nbrVects;
00185       }
00186 
00187       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;uint32&gt;</a><a class="code" href="classmap.html">::indexMap_t</a> tindexMap_t;
00188       tindexMap_t indeces;
00189       <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;uint32&gt;</a> vt( indeces, vects );
00190       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> tindexMap_t::const_iterator it =
00191                indeces.begin();
00192             it != indeces.<a class="code" href="classVectorIndexTable.html#a10">end</a>();
00193             ++it ) {
00194          <a class="code" href="MC2Logging_8h.html#a6">mc2dbg8</a> &lt;&lt; <span class="stringliteral">"[VTAB]: Index = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">", "</span>
00195                  &lt;&lt; it-&gt;second &lt;&lt; endl;
00196       }
00197       <a class="code" href="classDataBuffer.html">DataBuffer</a> buf( vt.<a class="code" href="classVectorIndexTable.html#a6">getSizeInDataBuffer</a>() );
00198       vt.<a class="code" href="classVectorIndexTable.html#a7">save</a>( buf );
00199       buf.reset();
00200       vt.<a class="code" href="classVectorIndexTable.html#a8">load</a>( buf );
00201       <a class="code" href="MC2Logging_8h.html#a2">mc2dbg</a> &lt;&lt; <span class="stringliteral">"[VTAB]::test returning"</span> &lt;&lt; endl;
00202       <span class="keywordflow">return</span> vects;
00203    }
00204 
00205 <span class="keyword">private</span>:
<a name="l00206"></a><a class="code" href="classVectorIndexTable.html#r0">00206</a>    VALUE_TYPE* m_array;
<a name="l00207"></a><a class="code" href="classVectorIndexTable.html#r1">00207</a>    <a class="code" href="Types_8h.html#a21">uint32</a>      m_arraySize;
00208    
00209 };
<a name="l00210"></a><a class="code" href="classVectorDataTable.html">00210</a> 
00211 <span class="keyword">template</span>&lt;<span class="keyword">class</span> VALUE_TYPE, <span class="keyword">class</span> ITEM_TABLE = ItemDataTable&lt;u<span class="keywordtype">int</span>32&gt; &gt;
00212 <span class="keyword">class </span><a class="code" href="classVectorDataTable.html">VectorDataTable</a> {
<a name="l00213"></a><a class="code" href="classVectorDataTable.html#w0">00213</a> <span class="keyword">public</span>:
<a name="l00214"></a><a class="code" href="classVectorDataTable.html#w1">00214</a> 
00215    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;VALUE_TYPE&gt;</a>::valMap_t valMap_t;
<a name="l00216"></a><a class="code" href="classVectorDataTable.html#a0">00216</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;VALUE_TYPE&gt;</a>::range_t range_t;
00217    
00218    <a class="code" href="classVectorDataTable.html">VectorDataTable</a>( <span class="keyword">const</span> valMap_t&amp; vals ) : m_itemTable( 0 ) {
00219       setValues( vals );
<a name="l00220"></a><a class="code" href="classVectorDataTable.html#a1">00220</a>    }
00221 
00222    <span class="keywordtype">void</span> setValues( <span class="keyword">const</span> valMap_t&amp; vals ) {
00223       <span class="keyword">typename</span> <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;VALUE_TYPE&gt;</a>::indexMap_t indeces;
00224       m_vectorTable.<a class="code" href="classVectorIndexTable.html#a5">setValues</a>( indeces, vals );
00225       m_itemTable.<a class="code" href="classVectorIndexTable.html#a5">setValues</a>( m_itemTable.getBestDefaultValue(indeces).second,
00226                              indeces );
00227 
00228       <a class="code" href="MC2Logging_8h.html#a2">mc2dbg</a> &lt;&lt; <span class="stringliteral">"[VDT]: Default value is "</span>
00229              &lt;&lt; m_itemTable.getBestDefaultValue(indeces).second
00230              &lt;&lt; endl;
00231       
00232       <span class="comment">// Check for correctness.</span>
00233       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> valMap_t::const_iterator it = vals.begin();
00234             it != vals.<a class="code" href="classVectorIndexTable.html#a10">end</a>();
00235             ++it ) {
00236          range_t r = range( it-&gt;first );
00237          <a class="code" href="config_8h.html#a29">MC2_ASSERT</a>( it-&gt;second ==
00238                      <span class="keyword">typename</span> valMap_t::value_type::second_type(r.first,
00239                                                                 r.second ) );
00240       }
<a name="l00241"></a><a class="code" href="classVectorDataTable.html#a2">00241</a>    }
00242 
00243    <a class="code" href="Types_8h.html#a21">uint32</a> getSizeInDataBuffer()<span class="keyword"> const </span>{
00244       <span class="keywordflow">return</span> m_vectorTable.<a class="code" href="classVectorIndexTable.html#a6">getSizeInDataBuffer</a>() +
00245              m_itemTable.<a class="code" href="classVectorIndexTable.html#a6">getSizeInDataBuffer</a>();
<a name="l00246"></a><a class="code" href="classVectorDataTable.html#a3">00246</a>    }
00247 
00248    <span class="keywordtype">void</span> <a class="code" href="namespaceTileFeatureScaleRange.html#a3">save</a>( <a class="code" href="classDataBuffer.html">DataBuffer</a>&amp; buf )<span class="keyword"> const </span>{
00249       m_vectorTable.<a class="code" href="classVectorIndexTable.html#a7">save</a>(buf);
00250       m_itemTable.<a class="code" href="classVectorIndexTable.html#a7">save</a>(buf);
<a name="l00251"></a><a class="code" href="classVectorDataTable.html#a4">00251</a>    }
00252 
00253    <span class="keywordtype">void</span> <a class="code" href="namespaceTileFeatureScaleRange.html#a4">load</a>( <a class="code" href="classDataBuffer.html">DataBuffer</a>&amp; buf ) {
00254       m_vectorTable.<a class="code" href="classVectorIndexTable.html#a8">load</a>( buf );
00255       m_itemTable.<a class="code" href="classVectorIndexTable.html#a8">load</a>( buf );
<a name="l00256"></a><a class="code" href="classVectorDataTable.html#a5">00256</a>    }
00257 
00258    range_t range( uint32 <span class="keywordtype">id</span> )<span class="keyword"> const </span>{
00259       <span class="keywordflow">return</span> m_vectorTable.<a class="code" href="classVectorIndexTable.html#a11">range</a>( m_itemTable.getData( <span class="keywordtype">id</span> ) );
<a name="l00260"></a><a class="code" href="classVectorDataTable.html#e0">00260</a>    }
00261 
00262    <span class="keyword">static</span> <span class="keywordtype">void</span> test() {
00263       valMap_t vals = <a class="code" href="classVectorIndexTable.html#e1">VectorIndexTable&lt;uint32&gt;::test</a>();
00264       <a class="code" href="classVectorDataTable.html">VectorDataTable&lt;uint32&gt;</a> table( vals );
00265       <a class="code" href="classDataBuffer.html">DataBuffer</a> buf( table.<a class="code" href="classVectorDataTable.html#a2">getSizeInDataBuffer</a>() );
00266       table.<a class="code" href="classVectorDataTable.html#a3">save</a>( buf );
00267       buf.reset();
00268       table.<a class="code" href="classVectorDataTable.html#a4">load</a>( buf );
00269       <span class="comment">// Check for correctness.</span>
00270       <span class="keywordflow">for</span> ( <span class="keyword">typename</span> valMap_t::const_iterator it = vals.begin();
00271             it != vals.end();
00272             ++it ) {
00273          range_t r = table.<a class="code" href="classVectorDataTable.html#a5">range</a>( it-&gt;first );
00274          <a class="code" href="config_8h.html#a29">MC2_ASSERT</a>( it-&gt;second ==
00275                      <span class="keyword">typename</span> valMap_t::value_type::second_type(r.first,
00276                                                                 r.second ) );
00277       }
00278       <a class="code" href="MC2Logging_8h.html#a2">mc2dbg</a> &lt;&lt; <span class="stringliteral">"[VectorDataTable]::test returns"</span> &lt;&lt; endl;      
00279    }
<a name="l00280"></a><a class="code" href="classVectorDataTable.html#r0">00280</a>    
<a name="l00281"></a><a class="code" href="classVectorDataTable.html#r1">00281</a> <span class="keyword">private</span>:
00282    ITEM_TABLE              m_itemTable;
00283    <a class="code" href="classVectorIndexTable.html">VectorIndexTable&lt;VALUE_TYPE&gt;</a> m_vectorTable;
00284    
00285 };
00286 
00287 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:51 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
